{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/Balancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Balancer {\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountOut, uint spotPriceAfter);\n    function swapExactAmountOut(\n        address tokenIn,\n        uint maxAmountIn,\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountIn, uint spotPriceAfter);\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        uint minPoolAmountOut\n    ) external returns (uint poolAmountOut);\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint poolAmountIn,\n        uint minAmountOut\n    ) external returns (uint tokenAmountOut);\n}\n"
    },
    "contracts/metavault/strategies/StrategyCurve3Crv.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Gauge.sol\";\nimport \"../../interfaces/Balancer.sol\";\n\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyCurve3Crv is BaseStrategy {\n    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route\n    address public immutable crv;\n\n    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    Mintr public immutable crvMintr;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n    Gauge public immutable gauge; // 3Crv Gauge\n\n    constructor(\n        address _want,\n        address _crv,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        Gauge _gauge,\n        Mintr _crvMintr,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _vaultManager,\n        address _router\n    )\n        public\n        BaseStrategy(_controller, _vaultManager, _want, _weth, _router)\n    {\n        crv = _crv;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        stableSwap3Pool = _stableSwap3Pool;\n        gauge = _gauge;\n        crvMintr = _crvMintr;\n        IERC20(_want).safeApprove(address(_gauge), type(uint256).max);\n        IERC20(_crv).safeApprove(address(_router), type(uint256).max);\n        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n    }\n\n    function _deposit() internal override {\n        uint256 _wantBal = balanceOfWant();\n        if (_wantBal > 0) {\n            // deposit [want] to Gauge\n            gauge.deposit(_wantBal);\n        }\n    }\n\n    function _claimReward() internal {\n        crvMintr.mint(address(gauge));\n    }\n\n    function _addLiquidity() internal {\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, 1);\n    }\n\n    function getMostPremium() public view returns (address, uint256) {\n        uint256[] memory balances = new uint256[](3);\n        balances[0] = stableSwap3Pool.balances(0); // DAI\n        balances[1] = stableSwap3Pool.balances(1).mul(10**12); // USDC\n        balances[2] = stableSwap3Pool.balances(2).mul(10**12); // USDT\n\n        if (balances[0] < balances[1] && balances[0] < balances[2]) { // DAI\n            return (dai, 0);\n        }\n\n        if (balances[1] < balances[0] && balances[1] < balances[2]) { // USDC\n            return (usdc, 1);\n        }\n\n        if (balances[2] < balances[0] && balances[2] < balances[1]) { // USDT\n            return (usdt, 2);\n        }\n\n        return (dai, 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest() internal override {\n        _claimReward();\n        uint256 _remainingWeth = _payHarvestFees(crv);\n\n        if (_remainingWeth > 0) {\n            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth);\n            _addLiquidity();\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdrawAll() internal override {\n        uint256 _bal = gauge.balanceOf(address(this));\n        _withdraw(_bal);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        gauge.withdraw(_amount);\n    }\n\n    function balanceOfPool() public view override returns (uint) {\n        return gauge.balanceOf(address(this));\n    }\n\n    function claimableTokens() external view returns (uint) {\n        return gauge.claimable_tokens(address(this));\n    }\n}\n"
    },
    "contracts/interfaces/Gauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Gauge {\n    function deposit(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function withdraw(uint) external;\n    function claimable_tokens(address) external view returns (uint);\n}\n\ninterface Mintr {\n    function mint(address) external;\n}\n"
    },
    "contracts/metavault/strategies/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../IStableSwap3Pool.sol\";\nimport \"../ISwap.sol\";\nimport \"../IVaultManager.sol\";\nimport \"../IStrategy.sol\";\nimport \"../IController.sol\";\n\n/**\n * @title BaseStrategy\n * @notice The BaseStrategy is an abstract contract which all\n * yAxis strategies should inherit functionality from. It gives\n * specific security properties which make it hard to write an\n * insecure strategy.\n * @notice All state-changing functions implemented in the strategy\n * should be internal, since any public or externally-facing functions\n * are already handled in the BaseStrategy.\n * @notice The following functions must be implemented by a strategy:\n * - function _deposit() internal virtual;\n * - function _harvest() internal virtual;\n * - function _withdraw(uint256 _amount) internal virtual;\n * - function _withdrawAll() internal virtual;\n * - function balanceOfPool() public view override virtual returns (uint256);\n */\nabstract contract BaseStrategy is IStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\n\n    address public immutable override want;\n    address public immutable weth;\n    address public controller;\n    IVaultManager public vaultManager;\n    ISwap public router;\n\n    /**\n     * @param _controller The address of the controller\n     * @param _vaultManager The address of the vaultManager\n     * @param _want The desired token of the strategy\n     * @param _weth The address of WETH\n     * @param _router The address of the router for swapping tokens\n     */\n    constructor(\n        address _controller,\n        address _vaultManager,\n        address _want,\n        address _weth,\n        address _router\n    ) public {\n        want = _want;\n        controller = _controller;\n        vaultManager = IVaultManager(_vaultManager);\n        weth = _weth;\n        router = ISwap(_router);\n        IERC20(_weth).safeApprove(address(_router), type(uint256).max);\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Approves a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(IERC20 _token, address _spender, uint256 _amount) external {\n        require(msg.sender == vaultManager.governance(), \"!governance\");\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Sets the address of the controller\n     * @param _controller The address of the controller\n     */\n    function setController(address _controller) external {\n        require(msg.sender == vaultManager.governance(), \"!governance\");\n        controller = _controller;\n    }\n\n    /**\n     * @notice Sets the address of the ISwap-compatible router\n     * @param _router The address of the router\n     */\n    function setRouter(address _router) external {\n        require(msg.sender == vaultManager.governance(), \"!governance\");\n        router = ISwap(_router);\n        IERC20(weth).safeApprove(address(_router), 0);\n        IERC20(weth).safeApprove(address(_router), type(uint256).max);\n    }\n\n    /**\n     * AUTHORIZED-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits funds to the strategy's pool\n     */\n    function deposit() external override onlyAuthorized {\n        _deposit();\n    }\n\n    /**\n     * @notice Harvest funds in the strategy's pool\n     */\n    function harvest() external override onlyAuthorized {\n        _harvest();\n    }\n\n    /**\n     * @notice Sends stuck want tokens in the strategy to the controller\n     */\n    function skim() external override onlyAuthorized {\n        IERC20(want).safeTransfer(controller, balanceOfWant());\n    }\n\n    /**\n     * @notice Sends stuck tokens in the strategy to the controller\n     * @param _asset The address of the token to withdraw\n     */\n    function withdraw(address _asset) external override onlyAuthorized {\n        require(want != _asset, \"want\");\n\n        IERC20 _assetToken = IERC20(_asset);\n        uint256 _balance = _assetToken.balanceOf(address(this));\n        _assetToken.safeTransfer(controller, _balance);\n    }\n\n    /**\n     * @notice Initiated from a vault, withdraws funds from the pool\n     * @param _amount The amount of the want token to withdraw\n     */\n    function withdraw(uint256 _amount) external override onlyAuthorized {\n        uint256 _balance = balanceOfWant();\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        address _token = _vaultWant();\n        address _vault = IController(controller).vaults(_token);\n        require(_vault != address(0), \"!vault\"); // additional protection so we don't burn the funds\n        IERC20(_token).safeTransfer(_vault, _amount);\n    }\n\n    /**\n     * @notice Withdraws all funds from the strategy\n     */\n    function withdrawAll() external override onlyAuthorized returns (uint256 _balance) {\n        _withdrawAll();\n\n        address _token = _vaultWant();\n        _balance = IERC20(_token).balanceOf(address(this));\n\n        address _vault = IController(controller).vaults(_token);\n        require(_vault != address(0), \"!vault\"); // additional protection so we don't burn the funds\n        IERC20(_token).safeTransfer(_vault, _balance);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the strategy's balance of the want token plus the balance of pool\n     */\n    function balanceOf() external override view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the balance of the pool\n     * @dev Must be implemented by the strategy\n     */\n    function balanceOfPool() public view override virtual returns (uint256);\n\n    /**\n     * @notice Returns the balance of the want token on the strategy\n     */\n    function balanceOfWant() public view override returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    function _deposit() internal virtual;\n\n    function _harvest() internal virtual;\n\n    function _payHarvestFees(\n        address _poolToken\n    ) internal returns (uint256 _wethBal) {\n        uint256 _amount = IERC20(_poolToken).balanceOf(address(this));\n        _swapTokens(_poolToken, weth, _amount);\n        _wethBal = IERC20(weth).balanceOf(address(this));\n\n        if (_wethBal > 0) {\n            // get all the necessary variables in a single call\n            (\n                address yax,\n                address stakingPool,\n                uint256 stakingPoolShareFee,\n                address treasury,\n                uint256 treasuryFee,\n                address insurance,\n                uint256 insurancePoolFee\n            ) = vaultManager.getHarvestFeeInfo();\n\n            uint256 _fee;\n\n            // pay the staking pool with YAX\n            if (stakingPoolShareFee > 0 && stakingPool != address(0)) {\n                _fee = _wethBal.mul(stakingPoolShareFee).div(ONE_HUNDRED_PERCENT);\n                _swapTokens(weth, yax, _fee);\n                IERC20(yax).safeTransfer(stakingPool, IERC20(yax).balanceOf(address(this)));\n            }\n\n            // pay the treasury with YAX\n            if (treasuryFee > 0 && treasury != address(0)) {\n                _fee = _wethBal.mul(treasuryFee).div(ONE_HUNDRED_PERCENT);\n                _swapTokens(weth, yax, _fee);\n                IERC20(yax).safeTransfer(treasury, IERC20(yax).balanceOf(address(this)));\n            }\n\n            // pay the insurance pool with YAX\n            if (insurancePoolFee > 0 && insurance != address(0)) {\n                _fee = _wethBal.mul(insurancePoolFee).div(ONE_HUNDRED_PERCENT);\n                _swapTokens(weth, yax, _fee);\n                IERC20(yax).safeTransfer(insurance, IERC20(yax).balanceOf(address(this)));\n            }\n\n            // return the remaining WETH balance\n            _wethBal = IERC20(weth).balanceOf(address(this));\n        }\n    }\n\n    function _swapTokens(address _input, address _output, uint256 _amount) internal {\n        address[] memory path = new address[](2);\n        path[0] = _input;\n        path[1] = _output;\n        router.swapExactTokensForTokens(\n            _amount,\n            1,\n            path,\n            address(this),\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp.add(1800)\n        );\n    }\n\n    function _vaultWant() internal returns (address) {\n        return IController(controller).strategyTokens(address(this));\n    }\n\n    function _withdraw(uint256 _amount) internal virtual;\n\n    function _withdrawAll() internal virtual;\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        address _token = _vaultWant();\n        uint256 _before = IERC20(_token).balanceOf(address(this));\n        _withdraw(_amount);\n        uint256 _after = IERC20(_token).balanceOf(address(this));\n        _amount = _after.sub(_before);\n\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyAuthorized() {\n        require(msg.sender == controller\n             || msg.sender == vaultManager.strategist()\n             || msg.sender == vaultManager.governance(),\n             \"!authorized\"\n        );\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/metavault/IStableSwap3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IStableSwap3Pool {\n    function get_virtual_price() external view returns (uint);\n    function balances(uint) external view returns (uint);\n    function get_dy(int128 i, int128 j, uint dx) external view returns (uint dy);\n    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;\n    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;\n    function remove_liquidity(uint _amount, uint[3] calldata amounts) external;\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;\n    function calc_token_amount(uint[3] calldata amounts, bool deposit) external view returns (uint);\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);\n}\n"
    },
    "contracts/metavault/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface ISwap {\n    function swapExactTokensForTokens(uint256, uint256, address[] calldata, address, uint256) external;\n}\n"
    },
    "contracts/metavault/IVaultManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IVaultManager {\n    function controllers(address) external view returns (bool);\n    function getHarvestFeeInfo() external view returns (address, address, uint256, address, uint256, address, uint256);\n    function governance() external view returns (address);\n    function harvester() external view returns (address);\n    function insuranceFee() external view returns (uint256);\n    function insurancePool() external view returns (address);\n    function insurancePoolFee() external view returns (uint256);\n    function stakingPool() external view returns (address);\n    function stakingPoolShareFee() external view returns (uint256);\n    function strategist() external view returns (address);\n    function treasury() external view returns (address);\n    function treasuryBalance() external view returns (uint256);\n    function treasuryFee() external view returns (uint256);\n    function vaults(address) external view returns (bool);\n    function withdrawalProtectionFee() external view returns (uint256);\n    function yax() external view returns (address);\n}\n"
    },
    "contracts/metavault/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IStrategy {\n    function balanceOf() external view returns (uint256);\n    function balanceOfPool() external view returns (uint256);\n    function balanceOfWant() external view returns (uint256);\n    function deposit() external;\n    function harvest() external;\n    function skim() external;\n    function want() external view returns (address);\n    function withdraw(address) external;\n    function withdraw(uint256) external;\n    function withdrawAll() external returns (uint256);\n}\n"
    },
    "contracts/metavault/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IController {\n    function balanceOf(address) external view returns (uint256);\n    function earn(address, uint256) external;\n    function investEnabled() external view returns (bool);\n    function harvestStrategy(address) external;\n    function strategyTokens(address) external returns (address);\n    function vaults(address) external view returns (address);\n    function want(address) external view returns (address);\n    function withdraw(address, uint256) external;\n    function withdrawFee(address, uint256) external view returns (uint256);\n}\n"
    },
    "contracts/metavault/strategies/StrategyStabilize.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Stabilize.sol\";\nimport \"../IConverter.sol\";\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyStabilize is BaseStrategy {\n    address public immutable zpaToken;\n    address public immutable pool;\n    address public immutable STBZ;\n    uint256 public immutable poolId;\n    IConverter public converter;\n\n    uint256 private depositTime; // The time the strategy made a deposit into zpa-Token, every deposit resets the time\n    uint256 private constant DIVISION_FACTOR = 100000;\n    uint256 private constant INITIAL_FEE = 1000; // 1000 = 1%, 100000 = 100%, max fee restricted in contract is 10%\n    uint256 private constant END_FEE = 100; // 100 = 0.1%\n    uint256 private constant FEE_DURATION = 604800; // The amount of seconds it takes from the initial to end fee\n\n    constructor(\n        address _underlying,\n        address _zpaToken,\n        address _pool,\n        uint256 _poolId,\n        address _STBZ,\n        address _converter,\n        address _controller,\n        address _vaultManager,\n        address _weth,\n        address _router\n    )\n        public\n        BaseStrategy(_controller, _vaultManager, _underlying, _weth, _router)\n    {\n        zpaToken = _zpaToken;\n        pool = _pool;\n        poolId = _poolId;\n        STBZ = _STBZ;\n        converter = IConverter(_converter);\n        IERC20(_STBZ).safeApprove(address(_router), type(uint256).max);\n        IERC20(_underlying).safeApprove(address(_converter), type(uint256).max);\n        IERC20(_underlying).safeApprove(_zpaToken, type(uint256).max);\n        IERC20(_zpaToken).safeApprove(_pool, type(uint256).max);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        uint256 zpaBalance = balanceOfzpaToken();\n        return (IZPAPool(pool).poolBalance(poolId, address(this)))\n            .mul(IZPAToken(zpaToken).pricePerToken())\n            .div(1e18)\n            .add(zpaBalance).sub(calculateZPATokenWithdrawFee(zpaBalance));\n    }\n\n    function balanceOfzpaToken() public view returns (uint256) {\n        return IERC20(zpaToken).balanceOf(address(this));\n    }\n\n    function calculateZPATokenWithdrawFee(uint256 amount) public view returns (uint256) {\n        uint256 _depositTime = depositTime;\n        if (_depositTime == 0) {\n            // Never deposited\n            _depositTime = block.timestamp; // Give the max fee\n        }\n\n        uint256 feeSubtraction = INITIAL_FEE.sub(END_FEE).mul(block.timestamp.sub(_depositTime)).div(FEE_DURATION);\n        if (feeSubtraction > INITIAL_FEE.sub(END_FEE)) {\n            // Cannot reduce fee more than this\n            feeSubtraction = INITIAL_FEE.sub(END_FEE);\n        }\n        uint256 fee = INITIAL_FEE.sub(feeSubtraction);\n        return amount.mul(fee).div(DIVISION_FACTOR);\n    }\n\n    function _deposit() internal override {\n        uint256 amount = balanceOfWant();\n        if (amount > 0) {\n            depositTime = block.timestamp;\n            IZPAToken(zpaToken).deposit(amount);\n        }\n        amount = balanceOfzpaToken();\n        if (amount > 0) {\n            IZPAPool(pool).deposit(poolId, amount);\n        }\n    }\n\n    function _harvest() internal override {\n        IZPAPool(pool).getReward(poolId);\n        uint256 remainingWeth = _payHarvestFees(STBZ);\n\n        if (remainingWeth > 0) {\n            _swapTokens(weth, want, remainingWeth);\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        _amount = _amount.mul(1e18).div(IZPAToken(zpaToken).pricePerToken());\n        uint256 _before = balanceOfzpaToken();\n        IZPAPool(pool).withdraw(poolId, _amount);\n        uint256 _after = balanceOfzpaToken();\n        _amount = _after.sub(_before);\n        IZPAToken(zpaToken).redeem(_amount);\n        _amount = balanceOfWant();\n        if (_amount > 0) {\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    function _withdrawAll() internal override {\n        uint256 amount = IZPAPool(pool).poolBalance(poolId, address(this));\n        IZPAPool(pool).exit(poolId, amount);\n\n        amount = balanceOfzpaToken();\n        if (amount > 0) {\n            IZPAToken(zpaToken).redeem(amount);\n            amount = balanceOfWant();\n            _convert(want, _vaultWant(), amount);\n        }\n    }\n\n    function _convert(address _from, address _to, uint256 _amount) internal {\n        require(converter.convert_rate(_from, _to, _amount) > 0, \"!convert_rate\");\n        IERC20(_from).safeTransfer(address(converter), _amount);\n        converter.convert(_from, _to, _amount);\n    }\n}\n"
    },
    "contracts/interfaces/Stabilize.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface IZPAToken {\n    function deposit(uint256) external;\n    function redeem(uint256) external;\n    function underlyingAsset() external view returns (address);\n    function pricePerToken() external view returns (uint256);\n\n    function initialFee() external view returns (uint256);\n    function endFee() external view returns (uint256);\n    function feeDuration() external view returns (uint256);\n}\n\ninterface IZPAPool {\n    function deposit(uint256, uint256) external;\n    function withdraw(uint256, uint256) external;\n    function exit(uint256, uint256) external;\n    function getReward(uint256) external;\n    function rewardEarned(uint256, address) external view returns (uint256);\n    function poolTokenAddress(uint256) external view returns (address);\n    function poolBalance(uint256, address) external view returns (uint256);\n}\n"
    },
    "contracts/metavault/IConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IConverter {\n    function token() external returns (address _share);\n    function convert(\n        address _input,\n        address _output,\n        uint _inputAmount\n    ) external returns (uint _outputAmount);\n    function convert_rate(\n        address _input,\n        address _output,\n        uint _inputAmount\n    ) external view returns (uint _outputAmount);\n    function convert_stables(\n        uint[3] calldata amounts\n    ) external returns (uint _shareAmount); // 0: DAI, 1: USDC, 2: USDT\n    function get_dy(int128 i, int128 j, uint dx) external view returns (uint);\n    function exchange(int128 i, int128 j, uint dx, uint min_dy) external returns (uint dy);\n    function calc_token_amount(\n        uint[3] calldata amounts,\n        bool deposit\n    ) external view returns (uint _shareAmount);\n    function calc_token_amount_withdraw(\n        uint _shares,\n        address _output\n    ) external view returns (uint _outputAmount);\n}\n"
    },
    "contracts/metavault/yAxisMetaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./IVaultManager.sol\";\nimport \"./IController.sol\";\nimport \"./IConverter.sol\";\nimport \"./IMetaVault.sol\";\n\n// @dev This metavault will pay YAX incentive for depositors and stakers\n// It does not need minter key of YAX. Governance multisig will mint total of 34000 YAX and send into the vault in the beginning\ncontract yAxisMetaVault is ERC20, IMetaVault {\n    using Address for address;\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    IERC20[4] public inputTokens; // DAI, USDC, USDT, 3Crv\n\n    IERC20 public token3CRV;\n    IERC20 public tokenYAX;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    uint public earnLowerlimit = 5 ether; // minimum to invest is 5 3CRV\n    uint public totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar\n\n    address public governance;\n    address public controller;\n    uint public insurance;\n    IVaultManager public vaultManager;\n    IConverter public converter;\n\n    bool public acceptContractDepositor = false; // dont accept contract at beginning\n\n    struct UserInfo {\n        uint amount;\n        uint yaxRewardDebt;\n        uint accEarned;\n    }\n\n    uint public lastRewardBlock;\n    uint public accYaxPerShare;\n\n    uint public yaxPerBlock;\n\n    mapping(address => UserInfo) public userInfo;\n\n    address public treasuryWallet = 0x362Db1c17db4C79B51Fe6aD2d73165b1fe9BaB4a;\n\n    uint public constant BLOCKS_PER_WEEK = 46500;\n\n    // Block number when each epoch ends.\n    uint[5] public epochEndBlocks;\n\n    // Reward multipler for each of 5 epoches (epochIndex: reward multipler)\n    uint[6] public epochRewardMultiplers = [86000, 64000, 43000, 21000, 10000, 1];\n\n    event Deposit(address indexed user, uint amount);\n    event Withdraw(address indexed user, uint amount);\n    event RewardPaid(address indexed user, uint reward);\n\n    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV, IERC20 _tokenYAX,\n        uint _yaxPerBlock, uint _startBlock) public ERC20(\"yAxis.io:MetaVault:3CRV\", \"MVLT\") {\n        inputTokens[0] = _tokenDAI;\n        inputTokens[1] = _tokenUSDC;\n        inputTokens[2] = _tokenUSDT;\n        inputTokens[3] = _token3CRV;\n        token3CRV = _token3CRV;\n        tokenYAX = _tokenYAX;\n        yaxPerBlock = _yaxPerBlock; // supposed to be 0.000001 YAX (1000000000000 = 1e12 wei)\n        lastRewardBlock = (_startBlock > block.number) ? _startBlock : block.number; // supposed to be 11,163,000 (Sat Oct 31 2020 06:30:00 GMT+0)\n        epochEndBlocks[0] = lastRewardBlock + BLOCKS_PER_WEEK * 2; // weeks 1-2\n        epochEndBlocks[1] = epochEndBlocks[0] + BLOCKS_PER_WEEK * 2; // weeks 3-4\n        epochEndBlocks[2] = epochEndBlocks[1] + BLOCKS_PER_WEEK * 4; // month 2\n        epochEndBlocks[3] = epochEndBlocks[2] + BLOCKS_PER_WEEK * 8; // month 3-4\n        epochEndBlocks[4] = epochEndBlocks[3] + BLOCKS_PER_WEEK * 8; // month 5-6\n        governance = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by a contract and we are not allowing.\n     */\n    modifier checkContract() {\n        if (!acceptContractDepositor) {\n            require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"Sorry we do not accept contract!\");\n        }\n        _;\n    }\n\n    // Ignore insurance fund for balance calculations\n    function balance() public override view returns (uint) {\n        uint bal = token3CRV.balanceOf(address(this));\n        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(token3CRV)));\n        return bal.sub(insurance);\n    }\n\n    function setMin(uint _min) external {\n        require(msg.sender == governance, \"!governance\");\n        min = _min;\n    }\n\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setController(address _controller) public override {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n\n    function setConverter(IConverter _converter) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_converter.token() == address(token3CRV), \"!token3CRV\");\n        converter = _converter;\n    }\n\n    function setVaultManager(IVaultManager _vaultManager) public {\n        require(msg.sender == governance, \"!governance\");\n        vaultManager = _vaultManager;\n    }\n\n    function setEarnLowerlimit(uint _earnLowerlimit) public {\n        require(msg.sender == governance, \"!governance\");\n        earnLowerlimit = _earnLowerlimit;\n    }\n\n    function setTotalDepositCap(uint _totalDepositCap) public {\n        require(msg.sender == governance, \"!governance\");\n        totalDepositCap = _totalDepositCap;\n    }\n\n    function setAcceptContractDepositor(bool _acceptContractDepositor) public {\n        require(msg.sender == governance, \"!governance\");\n        acceptContractDepositor = _acceptContractDepositor;\n    }\n\n    function setYaxPerBlock(uint _yaxPerBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        updateReward();\n        yaxPerBlock = _yaxPerBlock;\n    }\n\n    function setEpochEndBlock(uint8 _index, uint256 _epochEndBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index < 5, \"_index out of range\");\n        require(_epochEndBlock > block.number, \"Too late to update\");\n        require(epochEndBlocks[_index] > block.number, \"Too late to update\");\n        epochEndBlocks[_index] = _epochEndBlock;\n    }\n\n    function setEpochRewardMultipler(uint8 _index, uint256 _epochRewardMultipler) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index > 0 && _index < 6, \"Index out of range\");\n        require(epochEndBlocks[_index - 1] > block.number, \"Too late to update\");\n        epochRewardMultiplers[_index] = _epochRewardMultipler;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        for (uint8 epochId = 5; epochId >= 1; --epochId) {\n            if (_to >= epochEndBlocks[epochId - 1]) {\n                if (_from >= epochEndBlocks[epochId - 1]) return _to.sub(_from).mul(epochRewardMultiplers[epochId]);\n                uint256 multiplier = _to.sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]);\n                if (epochId == 1) return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n                for (epochId = epochId - 1; epochId >= 1; --epochId) {\n                    if (_from >= epochEndBlocks[epochId - 1]) return multiplier.add(epochEndBlocks[epochId].sub(_from).mul(epochRewardMultiplers[epochId]));\n                    multiplier = multiplier.add(epochEndBlocks[epochId].sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]));\n                }\n                return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n            }\n        }\n        return _to.sub(_from).mul(epochRewardMultiplers[0]);\n    }\n\n    function setTreasuryWallet(address _treasuryWallet) public {\n        require(msg.sender == governance, \"!governance\");\n        treasuryWallet = _treasuryWallet;\n    }\n\n    function claimInsurance() external override {\n        // if claim by controller for auto-compounding (current insurance will stay to increase sharePrice)\n        // otherwise send the fund to treasuryWallet\n        if (msg.sender != controller) {\n            // claim by governance for insurance\n            require(msg.sender == governance, \"!governance\");\n            token3CRV.safeTransfer(treasuryWallet, insurance);\n        }\n        insurance = 0;\n    }\n\n    function token() public override view returns (address) {\n        return address(token3CRV);\n    }\n\n    // Custom logic in here for how much the vault allows to be borrowed\n    // Sets minimum required on-hand to keep small withdrawals cheap\n    function available() public override view returns (uint) {\n        return token3CRV.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    function withdrawFee(uint _amount) public override view returns (uint) {\n        return (controller == address(0)) ? 0 : IController(controller).withdrawFee(address(token3CRV), _amount);\n    }\n\n    function earn() public override {\n        if (controller != address(0)) {\n            IController _contrl = IController(controller);\n            if (_contrl.investEnabled()) {\n                uint _bal = available();\n                token3CRV.safeTransfer(controller, _bal);\n                _contrl.earn(address(token3CRV), _bal);\n            }\n        }\n    }\n\n    function calc_token_amount_deposit(uint[3] calldata amounts) external override view returns (uint) {\n        return converter.calc_token_amount(amounts, true);\n    }\n\n    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {\n        uint _withdrawFee = withdrawFee(_shares);\n        if (_withdrawFee > 0) {\n            _shares = _shares.mul(10000 - _withdrawFee).div(10000);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        if (_output == address(token3CRV)) {\n            return r;\n        }\n        return converter.calc_token_amount_withdraw(r, _output);\n    }\n\n    function convert_rate(address _input, uint _amount) external override view returns (uint) {\n        return converter.convert_rate(_input, address(token3CRV), _amount);\n    }\n\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external override checkContract {\n        require(_amount > 0, \"!_amount\");\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        if (_input == address(token3CRV)) {\n            token3CRV.safeTransferFrom(msg.sender, address(this), _amount);\n        } else if (converter.convert_rate(_input, address(token3CRV), _amount) > 0) {\n            IERC20(_input).safeTransferFrom(msg.sender, address(converter), _amount);\n            converter.convert(_input, address(token3CRV), _amount);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_amount >= _min_mint_amount, \"slippage\");\n        if (_amount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _amount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _amount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    // Transfers tokens of all kinds\n    // 0: DAI, 1: USDT, 2: USDC, 3: 3CRV\n    function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        bool hasStables = false;\n        for (uint8 i = 0; i < 4; i++) {\n            uint _inputAmount = _amounts[i];\n            if (_inputAmount > 0) {\n                if (i == 3) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(this), _inputAmount);\n                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);\n                    hasStables = true;\n                }\n            }\n        }\n        if (hasStables) {\n            uint[3] memory _stablesAmounts;\n            _stablesAmounts[0] = _amounts[0];\n            _stablesAmounts[1] = _amounts[1];\n            _stablesAmounts[2] = _amounts[2];\n            converter.convert_stables(_stablesAmounts);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        uint _totalDepositAmount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_totalDepositAmount >= _min_mint_amount, \"slippage\");\n        if (_totalDepositAmount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _totalDepositAmount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    function stakeShares(uint _shares) external {\n        uint _before = balanceOf(address(this));\n        IERC20(address(this)).transferFrom(msg.sender, address(this), _shares);\n        uint _after = balanceOf(address(this));\n        _shares = _after.sub(_before);\n        // Additional check for deflationary tokens\n        _stakeShares(_shares);\n    }\n\n    function _deposit(address _mintTo, uint _pool, uint _amount) internal returns (uint _shares) {\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _insuranceFee = vaultManager.insuranceFee();\n            if (_insuranceFee > 0) {\n                uint _insurance = _amount.mul(_insuranceFee).div(10000);\n                _amount = _amount.sub(_insurance);\n                insurance = insurance.add(_insurance);\n            }\n        }\n\n        if (totalSupply() == 0) {\n            _shares = _amount;\n        } else {\n            _shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        if (_shares > 0) {\n            if (token3CRV.balanceOf(address(this)) > earnLowerlimit) {\n                earn();\n            }\n            _mint(_mintTo, _shares);\n        }\n    }\n\n    function _stakeShares(uint _shares) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        updateReward();\n        _getReward();\n        user.amount = user.amount.add(_shares);\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Deposit(msg.sender, _shares);\n    }\n\n    // View function to see pending YAXs on frontend.\n    function pendingYax(address _account) public view returns (uint _pending) {\n        UserInfo storage user = userInfo[_account];\n        uint _accYaxPerShare = accYaxPerShare;\n        uint lpSupply = balanceOf(address(this));\n        if (block.number > lastRewardBlock && lpSupply != 0) {\n            uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n            _accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        }\n        _pending = user.amount.mul(_accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n    }\n\n    function updateReward() public {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = balanceOf(address(this));\n        if (lpSupply == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n        uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n        accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        lastRewardBlock = block.number;\n    }\n\n    function _getReward() internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint _pendingYax = user.amount.mul(accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n        if (_pendingYax > 0) {\n            user.accEarned = user.accEarned.add(_pendingYax);\n            safeYaxTransfer(msg.sender, _pendingYax);\n            emit RewardPaid(msg.sender, _pendingYax);\n        }\n    }\n\n    function withdrawAll(address _output) external {\n        unstake(userInfo[msg.sender].amount);\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    // Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\n    function harvest(address reserve, uint amount) external override {\n        require(msg.sender == controller, \"!controller\");\n        require(reserve != address(token3CRV), \"token3CRV\");\n        IERC20(reserve).safeTransfer(controller, amount);\n    }\n\n    // call unstake(0) for getting reward\n    function unstake(uint _amount) public {\n        updateReward();\n        _getReward();\n        UserInfo storage user = userInfo[msg.sender];\n        if (_amount > 0) {\n            require(user.amount >= _amount, \"stakedBal < _amount\");\n            user.amount = user.amount.sub(_amount);\n            IERC20(address(this)).transfer(msg.sender, _amount);\n        }\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    // No rebalance implementation for lower fees and faster swaps\n    function withdraw(uint _shares, address _output) public override {\n        uint _userBal = balanceOf(msg.sender);\n        if (_shares > _userBal) {\n            uint _need = _shares.sub(_userBal);\n            require(_need <= userInfo[msg.sender].amount, \"_userBal+staked < _shares\");\n            unstake(_need);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of withdrawal go back to vault (for auto-compounding) to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _withdrawalProtectionFee = vaultManager.withdrawalProtectionFee();\n            if (_withdrawalProtectionFee > 0) {\n                uint _withdrawalProtection = r.mul(_withdrawalProtectionFee).div(10000);\n                r = r.sub(_withdrawalProtection);\n            }\n        }\n\n        // Check balance\n        uint b = token3CRV.balanceOf(address(this));\n        if (b < r) {\n            uint _toWithdraw = r.sub(b);\n            if (controller != address(0)) {\n                IController(controller).withdraw(address(token3CRV), _toWithdraw);\n            }\n            uint _after = token3CRV.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _toWithdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        if (_output == address(token3CRV)) {\n            token3CRV.safeTransfer(msg.sender, r);\n        } else {\n            require(converter.convert_rate(address(token3CRV), _output, r) > 0, \"rate=0\");\n            token3CRV.safeTransfer(address(converter), r);\n            uint _outputAmount = converter.convert(address(token3CRV), _output, r);\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n        }\n    }\n\n    function want() external override view returns (address) {\n        return address(token3CRV);\n    }\n\n    function getPricePerFullShare() external override view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    // Safe YAX transfer, ensure we have enough balance.\n    function safeYaxTransfer(address _to, uint _amount) internal {\n        uint _tokenBal = tokenYAX.balanceOf(address(this));\n        tokenYAX.safeTransfer(_to, (_tokenBal < _amount) ? _tokenBal : _amount);\n    }\n\n    // Only allows to earn some extra yield from non-core tokens - and auto-compounding the bought 3CRV\n    function earnExtra(address _token) public {\n        require(msg.sender == governance, \"!governance\");\n        require(address(_token) != address(token3CRV), \"3crv\");\n        require(address(_token) != address(this), \"mlvt\");\n        uint _amount = IERC20(_token).balanceOf(address(this));\n        require(converter.convert_rate(_token, address(token3CRV), _amount) > 0, \"rate=0\");\n        IERC20(_token).safeTransfer(address(converter), _amount);\n        converter.convert(_token, address(token3CRV), _amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/metavault/IMetaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IMetaVault {\n    function balance() external view returns (uint);\n    function setController(address _controller) external;\n    function claimInsurance() external;\n    function token() external view returns (address);\n    function available() external view returns (uint);\n    function withdrawFee(uint _amount) external view returns (uint);\n    function earn() external;\n    function calc_token_amount_deposit(uint[3] calldata amounts) external view returns (uint);\n    function calc_token_amount_withdraw(uint _shares, address _output) external view returns (uint);\n    function convert_rate(address _input, uint _amount) external view returns (uint);\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external;\n    function harvest(address reserve, uint amount) external;\n    function withdraw(uint _shares, address _output) external;\n    function want() external view returns (address);\n    function getPricePerFullShare() external view returns (uint);\n}\n"
    },
    "contracts/metavault/controllers/StrategyControllerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../IController.sol\";\nimport \"../IConverter.sol\";\nimport \"../IMetaVault.sol\";\nimport \"../IStrategy.sol\";\nimport \"../IVaultManager.sol\";\n\n/**\n * @title StrategyControllerV2\n * @notice This controller allows multiple strategies to be used\n * for a single token, and multiple tokens are supported.\n */\ncontract StrategyControllerV2 is IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    bool public globalInvestEnabled;\n    uint256 public maxStrategies;\n    IVaultManager public vaultManager;\n\n    struct TokenStrategy {\n        address[] strategies;\n        mapping(address => uint256) index;\n        mapping(address => bool) active;\n        mapping(address => uint256) caps;\n    }\n\n    // token => (want => converter)\n    mapping(address => mapping(address => address)) public converters;\n    // token => TokenStrategy\n    mapping(address => TokenStrategy) internal tokenStrategies;\n    // strategy => token\n    mapping(address => address) public override strategyTokens;\n    // token => vault\n    mapping(address => address) public override vaults;\n    // vault => token\n    mapping(address => address) public vaultTokens;\n\n    /**\n     * @notice Logged when earn is called for a strategy\n     */\n    event Earn(address indexed strategy);\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(address indexed strategy);\n\n    /**\n     * @notice Logged when insurance is claimed for a vault\n     */\n    event InsuranceClaimed(address indexed vault);\n\n    /**\n     * @notice Logged when a strategy is added for a token\n     */\n    event StrategyAdded(address indexed token, address indexed strategy, uint256 cap);\n\n    /**\n     * @notice Logged when a strategy is removed for a token\n     */\n    event StrategyRemoved(address indexed token, address indexed strategy);\n\n    /**\n     * @notice Logged when strategies are reordered for a token\n     */\n    event StrategiesReordered(\n        address indexed token,\n        address indexed strategy1,\n        address indexed strategy2\n    );\n\n    /**\n     * @param _vaultManager The address of the vaultManager\n     */\n    constructor(address _vaultManager) public {\n        vaultManager = IVaultManager(_vaultManager);\n        globalInvestEnabled = true;\n        maxStrategies = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy for a given token\n     * @dev Only callable by governance\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     * @param _cap The cap of the strategy\n     */\n    function addStrategy(\n        address _token,\n        address _strategy,\n        uint256 _cap\n    ) external onlyGovernance {\n        // ensure the strategy hasn't been added\n        require(!tokenStrategies[_token].active[_strategy], \"active\");\n        address _want = IStrategy(_strategy).want();\n        // ensure a converter is added if the strategy's want token is\n        // different than the want token of the vault\n        if (_want != IMetaVault(vaults[_token]).want()) {\n            require(converters[_token][_want] != address(0), \"!converter\");\n        }\n        // get the index of the newly added strategy\n        uint256 index = tokenStrategies[_token].strategies.length;\n        // ensure we haven't added too many strategies already\n        require(index < maxStrategies, \"!maxStrategies\");\n        // push the strategy to the array of strategies\n        tokenStrategies[_token].strategies.push(_strategy);\n        // set the cap\n        tokenStrategies[_token].caps[_strategy] = _cap;\n        // set the index\n        tokenStrategies[_token].index[_strategy] = index;\n        // activate the strategy\n        tokenStrategies[_token].active[_strategy] = true;\n        // store the reverse mapping\n        strategyTokens[_strategy] = _token;\n        emit StrategyAdded(_token, _strategy, _cap);\n    }\n\n    /**\n     * @notice Claims the insurance fund of a vault\n     * @dev Only callable by governance\n     * @dev When insurance is claimed by the controller, the insurance fund of\n     * the vault is zeroed out, increasing the getPricePerFullShare and applying\n     * the gains to everyone in the vault.\n     * @param _vault The address of the vault\n     */\n    function claimInsurance(address _vault) external onlyGovernance {\n        IMetaVault(_vault).claimInsurance();\n        emit InsuranceClaimed(_vault);\n    }\n\n    /**\n     * @notice Sets the address of the vault manager contract\n     * @dev Only callable by governance\n     * @param _vaultManager The address of the vault manager\n     */\n    function setVaultManager(address _vaultManager) external onlyGovernance {\n        vaultManager = IVaultManager(_vaultManager);\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Withdraws token from a strategy to governance\n     * @dev Only callable by governance or the strategist\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     */\n    function inCaseStrategyGetStuck(\n        address _strategy,\n        address _token\n    ) external onlyStrategist {\n        IStrategy(_strategy).withdraw(_token);\n        IERC20(_token).safeTransfer(\n            vaultManager.governance(),\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Withdraws token from the controller to governance\n     * @dev Only callable by governance or the strategist\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function inCaseTokensGetStuck(\n        address _token,\n        uint256 _amount\n    ) external onlyStrategist {\n        IERC20(_token).safeTransfer(vaultManager.governance(), _amount);\n    }\n\n    /**\n     * @notice Removes a strategy for a given token\n     * @dev Only callable by governance or strategist\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     */\n    function removeStrategy(\n        address _token,\n        address _strategy\n    ) external onlyStrategist {\n        TokenStrategy storage tokenStrategy = tokenStrategies[_token];\n        // ensure the strategy is already added\n        require(tokenStrategy.active[_strategy], \"!active\");\n        // get the index of the strategy to remove\n        uint256 index = tokenStrategy.index[_strategy];\n        // get the index of the last strategy\n        uint256 tail = tokenStrategy.strategies.length.sub(1);\n        // get the address of the last strategy\n        address replace = tokenStrategy.strategies[tail];\n        // replace the removed strategy with the tail\n        tokenStrategy.strategies[index] = replace;\n        // set the new index for the replaced strategy\n        tokenStrategy.index[replace] = index;\n        // remove the duplicate replaced strategy\n        tokenStrategy.strategies.pop();\n        // remove the strategy's index\n        delete tokenStrategy.index[_strategy];\n        // remove the strategy's cap\n        delete tokenStrategy.caps[_strategy];\n        // deactivate the strategy\n        delete tokenStrategy.active[_strategy];\n        // pull funds from the removed strategy to the vault\n        IStrategy(_strategy).withdrawAll();\n        emit StrategyRemoved(_token, _strategy);\n    }\n\n    /**\n     * @notice Reorders two strategies for a given token\n     * @dev Only callable by governance or strategist\n     * @param _token The address of the token\n     * @param _strategy1 The address of the first strategy\n     * @param _strategy2 The address of the second strategy\n     */\n    function reorderStrategies(\n        address _token,\n        address _strategy1,\n        address _strategy2\n    ) external onlyStrategist {\n        TokenStrategy storage tokenStrategy = tokenStrategies[_token];\n        // ensure the strategies are already added\n        require(tokenStrategy.active[_strategy1]\n             && tokenStrategy.active[_strategy2],\n             \"!active\");\n        // get the indexes of the strategies\n        uint256 index1 = tokenStrategy.index[_strategy1];\n        uint256 index2 = tokenStrategy.index[_strategy2];\n        // set the new addresses at their indexes\n        tokenStrategy.strategies[index1] = _strategy2;\n        tokenStrategy.strategies[index2] = _strategy1;\n        // update indexes\n        tokenStrategy.index[_strategy1] = index2;\n        tokenStrategy.index[_strategy2] = index1;\n        emit StrategiesReordered(_token, _strategy1, _strategy2);\n    }\n\n    /**\n     * @notice Sets/updates the cap of a strategy for a token\n     * @dev Only callable by governance or strategist\n     * @dev If the balance of the strategy is greater than the new cap (except if\n     * the cap is 0), then withdraw the difference from the strategy to the vault.\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     * @param _cap The new cap of the strategy\n     */\n    function setCap(\n        address _token,\n        address _strategy,\n        uint256 _cap\n    ) external onlyStrategist {\n        require(tokenStrategies[_token].active[_strategy], \"!active\");\n        tokenStrategies[_token].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n        }\n    }\n\n    /**\n     * @notice Sets/updates the converter for given input and output tokens\n     * @dev Only callable by governance or strategist\n     * @param _input The address of the input token\n     * @param _output The address of the output token\n     * @param _converter The address of the converter\n     */\n    function setConverter(\n        address _input,\n        address _output,\n        address _converter\n    ) external onlyStrategist {\n        converters[_input][_output] = _converter;\n    }\n\n    /**\n     * @notice Sets/updates the global invest enabled flag\n     * @dev Only callable by governance or strategist\n     * @param _investEnabled The new bool of the invest enabled flag\n     */\n    function setInvestEnabled(bool _investEnabled) external onlyStrategist {\n        globalInvestEnabled = _investEnabled;\n    }\n\n    /**\n     * @notice Sets/updates the maximum number of strategies for a token\n     * @dev Only callable by governance or strategist\n     * @param _maxStrategies The new value of the maximum strategies\n     */\n    function setMaxStrategies(uint256 _maxStrategies) external onlyStrategist {\n      maxStrategies = _maxStrategies;\n    }\n\n    /**\n     * @notice Sets the address of a vault for a given token\n     * @dev Only callable by governance or strategist\n     * @param _token The address of the token\n     * @param _vault The address of the vault\n     */\n    function setVault(address _token, address _vault) external onlyStrategist {\n        require(vaults[_token] == address(0), \"vault\");\n        vaults[_token] = _vault;\n        vaultTokens[_vault] = _token;\n    }\n\n    /**\n     * @notice Withdraws all funds from a strategy\n     * @dev Only callable by governance or the strategist\n     * @param _strategy The address of the strategy\n     */\n    function withdrawAll(address _strategy) external onlyStrategist {\n        // WithdrawAll sends 'want' to 'vault'\n        IStrategy(_strategy).withdrawAll();\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST|HARVESTER)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Harvests the specified strategy\n     * @dev Only callable by governance, the strategist, or the harvester\n     * @param _strategy The address of the strategy\n     */\n    function harvestStrategy(address _strategy) external override onlyHarvester {\n        IStrategy(_strategy).harvest();\n        emit Harvest(_strategy);\n    }\n\n    /**\n     * VAULT-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Invests funds into a strategy\n     * @dev Only callable by a vault\n     * @param _token The address of the token\n     * @param _amount The amount that will be invested\n     */\n    function earn(address _token, uint256 _amount) external override onlyVault(_token) {\n        // get the first strategy that will accept the deposit\n        address _strategy = getBestStrategyEarn(_token, _amount);\n        // get the want token of the strategy\n        address _want = IStrategy(_strategy).want();\n        // if the depositing token is not what the strategy wants, convert it\n        // then transfer it to the strategy\n        if (_want != _token) {\n            address _converter = converters[_token][_want];\n            IERC20(_token).safeTransfer(_converter, _amount);\n            _amount = IConverter(_converter).convert(\n                _token,\n                _want,\n                _amount\n            );\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        // call the strategy's deposit function\n        IStrategy(_strategy).deposit();\n        emit Earn(_strategy);\n    }\n\n    /**\n     * @notice Withdraws funds from a strategy\n     * @dev Only callable by a vault\n     * @dev If the withdraw amount is greater than the first strategy given\n     * by getBestStrategyWithdraw, this function will loop over strategies\n     * until the requested amount is met.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function withdraw(address _token, uint256 _amount) external override onlyVault(_token) {\n        (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        ) = getBestStrategyWithdraw(_token, _amount);\n        for (uint i = 0; i < _strategies.length; i++) {\n            // getBestStrategyWithdraw will return arrays larger than needed\n            // if this happens, simply exit the loop\n            if (_strategies[i] == address(0)) {\n                break;\n            }\n            IStrategy(_strategies[i]).withdraw(_amounts[i]);\n        }\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the balance of the sum of all strategies for a given token\n     * @dev This function would make deposits more expensive for the more strategies\n     * that are added for a given token\n     * @param _token The address of the token\n     */\n    function balanceOf(address _token) external view override returns (uint256 _balance) {\n        uint256 k = tokenStrategies[_token].strategies.length;\n        for (uint i = 0; i < k; i++) {\n            IStrategy _strategy = IStrategy(tokenStrategies[_token].strategies[i]);\n            address _want = _strategy.want();\n            if (_want != _token) {\n                address _converter = converters[_token][_want];\n                _balance = _balance.add(IConverter(_converter).convert_rate(\n                    _want,\n                    _token,\n                    _strategy.balanceOf()\n               ));\n            } else {\n                _balance = _balance.add(_strategy.balanceOf());\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the cap of a strategy for a given token\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     */\n    function getCap(address _token, address _strategy) external view returns (uint256) {\n        return tokenStrategies[_token].caps[_strategy];\n    }\n\n    /**\n     * @notice Returns whether investing is enabled for the calling vault\n     * @dev Should be called by the vault\n     */\n    function investEnabled() external view override returns (bool) {\n        if (globalInvestEnabled) {\n            return tokenStrategies[vaultTokens[msg.sender]].strategies.length > 0;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns all the strategies for a given token\n     * @param _token The address of the token\n     */\n    function strategies(address _token) external view returns (address[] memory) {\n        return tokenStrategies[_token].strategies;\n    }\n\n    /**\n     * @notice Returns the want address of a given token\n     * @dev Since strategies can have different want tokens, default to using the\n     * want token of the vault for a given token.\n     * @param _token The address of the token\n     */\n    function want(address _token) external view override returns (address) {\n        return IMetaVault(vaults[_token]).want();\n    }\n\n    /**\n     * @notice Returns the fee for withdrawing a specified amount\n     * @param _amount The amount that will be withdrawn\n     */\n    function withdrawFee(\n        address,\n        uint256 _amount\n    ) external view override returns (uint256 _fee) {\n        return vaultManager.withdrawalProtectionFee().mul(_amount).div(10000);\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the best (optimistic) strategy for funds to be sent to with earn\n     * @param _token The address of the token\n     * @param _amount The amount that will be invested\n     */\n    function getBestStrategyEarn(\n        address _token,\n        uint256 _amount\n    ) public view returns (address _strategy) {\n        // get the index of the last strategy\n        uint256 k = tokenStrategies[_token].strategies.length.sub(1);\n        // scan backwards from the index to the beginning of strategies\n        for (uint i = k; i >= 0; i--) {\n            _strategy = tokenStrategies[_token].strategies[i];\n            // get the new balance if the _amount were added to the strategy\n            uint256 balance = IStrategy(_strategy).balanceOf().add(_amount);\n            uint256 cap = tokenStrategies[_token].caps[_strategy];\n            // stop scanning if the deposit wouldn't go over the cap\n            if (balance <= cap || cap == 0) {\n                break;\n            }\n        }\n        // if never broken from the loop, use the last scanned strategy\n        // this could cause it to go over cap if (for some reason) no strategies\n        // were added with 0 cap\n    }\n\n    /**\n     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from\n     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays\n     * from this function will always be the same length as the amount of strategies for\n     * a token. Check that _strategies[i] != address(0) when consuming to know when to\n     * break out of the loop.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function getBestStrategyWithdraw(\n        address _token,\n        uint256 _amount\n    ) public view returns (\n        address[] memory _strategies,\n        uint256[] memory _amounts\n    ) {\n        // get the length of strategies\n        uint256 k = tokenStrategies[_token].strategies.length;\n        // initialize fixed-length memory arrays\n        _strategies = new address[](k);\n        _amounts = new uint256[](k);\n        // scan forward from the the beginning of strategies\n        for (uint i = 0; i < k; i++) {\n            address _strategy = tokenStrategies[_token].strategies[i];\n            _strategies[i] = _strategy;\n            // get the balance of the strategy\n            uint256 _balance = IStrategy(_strategy).balanceOf();\n            // if the strategy doesn't have the balance to cover the withdraw\n            if (_balance < _amount) {\n                // withdraw what we can and add to the _amounts\n                _amounts[i] = _balance;\n                _amount = _amount.sub(_balance);\n            } else {\n                // stop scanning if the balance is more than the withdraw amount\n                _amounts[i] = _amount;\n                break;\n            }\n        }\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyGovernance() {\n        require(msg.sender == vaultManager.governance(), \"!governance\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == vaultManager.strategist()\n             || msg.sender == vaultManager.governance(),\n             \"!strategist\"\n        );\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(\n            msg.sender == vaultManager.harvester() ||\n            msg.sender == vaultManager.strategist() ||\n            msg.sender == vaultManager.governance(),\n            \"!harvester\"\n        );\n        _;\n    }\n\n    modifier onlyVault(address _token) {\n        require(msg.sender == vaults[_token], \"!vault\");\n        _;\n    }\n}\n"
    },
    "contracts/metavault/yAxisMetaVaultManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IVaultManager.sol\";\n\n/**\n * @title yAxisMetaVaultManager\n * @notice This contract serves as the central point for governance-voted\n * variables. Fees and permissioned addresses are stored and referenced in\n * this contract only.\n */\ncontract yAxisMetaVaultManager is IVaultManager { // solhint-disable-line contract-name-camelcase\n    address public override governance;\n    address public override harvester;\n    address public override insurancePool;\n    address public override stakingPool;\n    address public override strategist;\n    address public override treasury;\n    address public override yax;\n\n    /**\n     *  The following fees are all mutable.\n     *  They are updated by governance (community vote).\n     */\n    uint256 public override insuranceFee;\n    uint256 public override insurancePoolFee;\n    uint256 public override stakingPoolShareFee;\n    uint256 public override treasuryBalance;\n    uint256 public override treasuryFee;\n    uint256 public override withdrawalProtectionFee;\n\n    mapping(address => bool) public override vaults;\n    mapping(address => bool) public override controllers;\n\n    /**\n     * @param _yax The address of the YAX token\n     */\n    constructor(address _yax) public {\n        yax = _yax;\n        governance = msg.sender;\n        strategist = msg.sender;\n        harvester = msg.sender;\n        stakingPoolShareFee = 2000;\n        treasuryBalance = 20000e18;\n        treasuryFee = 500;\n        withdrawalProtectionFee = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Allows governance to pull tokens out of this contract\n     * (it should never hold tokens)\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to send to\n     */\n    function governanceRecoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    ) external {\n        require(msg.sender == governance, \"!governance\");\n        _token.transfer(_to, _amount);\n    }\n\n    /**\n     * @notice Sets the governance address\n     * @param _governance The address of the governance\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    /**\n     * @notice Sets the insurance fee\n     * @dev Throws if setting fee over 1%\n     * @param _insuranceFee The value for the insurance fee\n     */\n    function setInsuranceFee(uint256 _insuranceFee) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_insuranceFee <= 100, \"_insuranceFee over 1%\");\n        insuranceFee = _insuranceFee;\n    }\n\n    /**\n     * @notice Sets the insurance pool address\n     * @param _insurancePool The address of the insurance pool\n     */\n    function setInsurancePool(address _insurancePool) public {\n        require(msg.sender == governance, \"!governance\");\n        insurancePool = _insurancePool;\n    }\n\n    /**\n     * @notice Sets the insurance pool fee\n     * @dev Throws if setting fee over 20%\n     * @param _insurancePoolFee The value for the insurance pool fee\n     */\n    function setInsurancePoolFee(uint256 _insurancePoolFee) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_insurancePoolFee <= 2000, \"_insurancePoolFee over 20%\");\n        insurancePoolFee = _insurancePoolFee;\n    }\n\n    /**\n     * @notice Sets the staking pool address\n     * @param _stakingPool The address of the staking pool\n     */\n    function setStakingPool(address _stakingPool) public {\n        require(msg.sender == governance, \"!governance\");\n        stakingPool = _stakingPool;\n    }\n\n    /**\n     * @notice Sets the staking pool share fee\n     * @dev Throws if setting fee over 50%\n     * @param _stakingPoolShareFee The value for the staking pool fee\n     */\n    function setStakingPoolShareFee(uint256 _stakingPoolShareFee) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_stakingPoolShareFee <= 5000, \"_stakingPoolShareFee over 50%\");\n        stakingPoolShareFee = _stakingPoolShareFee;\n    }\n\n    /**\n     * @notice Sets the strategist address\n     * @param _strategist The address of the strategist\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @notice Sets the treasury address\n     * @param _treasury The address of the treasury\n     */\n    function setTreasury(address _treasury) public {\n        require(msg.sender == governance, \"!governance\");\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Sets the maximum treasury balance\n     * @dev Strategies will read this value to determine whether or not\n     * to give the treasury the treasuryFee\n     * @param _treasuryBalance The maximum balance of the treasury\n     */\n    function setTreasuryBalance(uint256 _treasuryBalance) public {\n        require(msg.sender == governance, \"!governance\");\n        treasuryBalance = _treasuryBalance;\n    }\n\n    /**\n     * @notice Sets the treasury fee\n     * @dev Throws if setting fee over 20%\n     * @param _treasuryFee The value for the treasury fee\n     */\n    function setTreasuryFee(uint256 _treasuryFee) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_treasuryFee <= 2000, \"_treasuryFee over 20%\");\n        treasuryFee = _treasuryFee;\n    }\n\n    /**\n     * @notice Sets the withdrawal protection fee\n     * @dev Throws if setting fee over 1%\n     * @param _withdrawalProtectionFee The value for the withdrawal protection fee\n     */\n    function setWithdrawalProtectionFee(uint256 _withdrawalProtectionFee) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_withdrawalProtectionFee <= 100, \"_withdrawalProtectionFee over 1%\");\n        withdrawalProtectionFee = _withdrawalProtectionFee;\n    }\n\n    /**\n     * @notice Sets the YAX address\n     * @param _yax The address of the YAX token\n     */\n    function setYax(address _yax) external {\n        require(msg.sender == governance, \"!governance\");\n        yax = _yax;\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the status for a controller\n     * @param _controller The address of the controller\n     * @param _status The status of the controller\n     */\n    function setControllerStatus(address _controller, bool _status) external {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        controllers[_controller] = _status;\n    }\n\n    /**\n     * @notice Sets the harvester address\n     * @param _harvester The address of the harvester\n     */\n    function setHarvester(address _harvester) external {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        harvester = _harvester;\n    }\n\n    /**\n     * @notice Sets the status for a vault\n     * @param _vault The address of the vault\n     * @param _status The status of the vault\n     */\n    function setVaultStatus(address _vault, bool _status) external {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        vaults[_vault] = _status;\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns a tuple of:\n     *     YAX token,\n     *     Staking pool address,\n     *     Staking pool share fee,\n     *     Treasury address,\n     *     Checks the balance of the treasury and returns the treasury fee\n     *         if below the treasuryBalance, or 0 if above\n     */\n    function getHarvestFeeInfo()\n        external\n        view\n        override\n        returns (address, address, uint256, address, uint256, address, uint256)\n    {\n        return (\n            yax,\n            stakingPool,\n            stakingPoolShareFee,\n            treasury,\n            IERC20(yax).balanceOf(treasury) >= treasuryBalance ? 0 : treasuryFee,\n            insurancePool,\n            insurancePoolFee\n        );\n    }\n}\n"
    },
    "contracts/metavault/StableSwap3PoolConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./IConverter.sol\";\nimport \"./IVaultManager.sol\";\nimport \"./IStableSwap3Pool.sol\";\n\ncontract StableSwap3PoolConverter is IConverter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20[3] public tokens; // DAI, USDC, USDT\n    IERC20 public token3CRV; // 3Crv\n\n    IStableSwap3Pool public stableSwap3Pool;\n    IVaultManager public vaultManager;\n\n    mapping(address => bool) public strategies;\n\n    constructor(\n        IERC20 _tokenDAI,\n        IERC20 _tokenUSDC,\n        IERC20 _tokenUSDT,\n        IERC20 _token3CRV,\n        IStableSwap3Pool _stableSwap3Pool,\n        IVaultManager _vaultManager\n    ) public {\n        tokens[0] = _tokenDAI;\n        tokens[1] = _tokenUSDC;\n        tokens[2] = _tokenUSDT;\n        token3CRV = _token3CRV;\n        stableSwap3Pool = _stableSwap3Pool;\n        tokens[0].safeApprove(address(stableSwap3Pool), type(uint256).max);\n        tokens[1].safeApprove(address(stableSwap3Pool), type(uint256).max);\n        tokens[2].safeApprove(address(stableSwap3Pool), type(uint256).max);\n        token3CRV.safeApprove(address(stableSwap3Pool), type(uint256).max);\n        vaultManager = _vaultManager;\n    }\n\n    function setStableSwap3Pool(IStableSwap3Pool _stableSwap3Pool) external onlyGovernance {\n        stableSwap3Pool = _stableSwap3Pool;\n        tokens[0].safeApprove(address(stableSwap3Pool), type(uint256).max);\n        tokens[1].safeApprove(address(stableSwap3Pool), type(uint256).max);\n        tokens[2].safeApprove(address(stableSwap3Pool), type(uint256).max);\n        token3CRV.safeApprove(address(stableSwap3Pool), type(uint256).max);\n    }\n\n    function setVaultManager(IVaultManager _vaultManager) external onlyGovernance {\n        vaultManager = _vaultManager;\n    }\n\n    function setStrategy(address _strategy, bool _status) external onlyGovernance {\n        strategies[_strategy] = _status;\n    }\n\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyGovernance {\n        _token.safeApprove(_spender, _amount);\n    }\n\n    function token() external override returns (address) {\n        return address(token3CRV);\n    }\n\n    function convert(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    ) external override onlyAuthorized returns (uint256 _outputAmount) {\n        if (_output == address(token3CRV)) { // convert to 3CRV\n            uint256[3] memory amounts;\n            for (uint8 i = 0; i < 3; i++) {\n                if (_input == address(tokens[i])) {\n                    amounts[i] = _inputAmount;\n                    uint256 _before = token3CRV.balanceOf(address(this));\n                    stableSwap3Pool.add_liquidity(amounts, 1);\n                    uint256 _after = token3CRV.balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    token3CRV.safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else if (_input == address(token3CRV)) { // convert from 3CRV\n            for (uint8 i = 0; i < 3; i++) {\n                if (_output == address(tokens[i])) {\n                    uint256 _before = tokens[i].balanceOf(address(this));\n                    stableSwap3Pool.remove_liquidity_one_coin(_inputAmount, i, 1);\n                    uint256 _after = tokens[i].balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    tokens[i].safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        }\n        return 0;\n    }\n\n    function convert_rate(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    ) external override view returns (uint256) {\n        if (_output == address(token3CRV)) { // convert to 3CRV\n            uint256[3] memory amounts;\n            for (uint8 i = 0; i < 3; i++) {\n                if (_input == address(tokens[i])) {\n                    amounts[i] = _inputAmount;\n                    return stableSwap3Pool.calc_token_amount(amounts, true);\n                }\n            }\n        } else if (_input == address(token3CRV)) { // convert from 3CRV\n            for (uint8 i = 0; i < 3; i++) {\n                if (_output == address(tokens[i])) {\n                    // @dev this is for UI reference only, the actual share price\n                    // (stable/CRV) will be re-calculated on-chain when we do convert()\n                    return stableSwap3Pool.calc_withdraw_one_coin(_inputAmount, i);\n                }\n            }\n        }\n        return 0;\n    }\n\n    // 0: DAI, 1: USDC, 2: USDT\n    function convert_stables(\n        uint256[3] calldata amounts\n    ) external override onlyAuthorized returns (uint256 _shareAmount) {\n        uint256 _before = token3CRV.balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, 1);\n        uint256 _after = token3CRV.balanceOf(address(this));\n        _shareAmount = _after.sub(_before);\n        token3CRV.safeTransfer(msg.sender, _shareAmount);\n    }\n\n    function get_dy(int128 i, int128 j, uint256 dx) external override view returns (uint256) {\n        return stableSwap3Pool.get_dy(i, j, dx);\n    }\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external override onlyAuthorized returns (uint256 dy) {\n        IERC20 _output = tokens[uint8(j)];\n        uint256 _before = _output.balanceOf(address(this));\n        stableSwap3Pool.exchange(i, j, dx, min_dy);\n        uint256 _after = _output.balanceOf(address(this));\n        dy = _after.sub(_before);\n        _output.safeTransfer(msg.sender, dy);\n    }\n\n    function calc_token_amount(\n        uint256[3] calldata amounts,\n        bool deposit\n    ) external override view returns (uint256 _shareAmount) {\n        _shareAmount = stableSwap3Pool.calc_token_amount(amounts, deposit);\n    }\n\n    function calc_token_amount_withdraw(\n        uint256 _shares,\n        address _output\n    ) external override view returns (uint256) {\n        for (uint8 i = 0; i < 3; i++) {\n            if (_output == address(tokens[i])) {\n                return stableSwap3Pool.calc_withdraw_one_coin(_shares, i);\n            }\n        }\n        return 0;\n    }\n\n    function governanceRecoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    ) external onlyGovernance {\n        _token.transfer(_to, _amount);\n    }\n\n    modifier onlyAuthorized() {\n        require(vaultManager.vaults(msg.sender)\n            || vaultManager.controllers(msg.sender)\n            || strategies[msg.sender]\n            || msg.sender == vaultManager.governance(),\n            \"!authorized\"\n        );\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == vaultManager.governance(), \"!governance\");\n        _;\n    }\n}\n"
    },
    "contracts/metavault/strategies/StrategyPickle3Crv.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../IStableSwap3Pool.sol\";\n\nimport \"../../interfaces/PickleJar.sol\";\nimport \"../../interfaces/PickleMasterChef.sol\";\n\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyPickle3Crv is BaseStrategy {\n    address public immutable p3crv;\n\n    // used for pickle -> weth -> [stableForAddLiquidity] -> 3crv route\n    address public immutable pickle;\n\n    // for add_liquidity via curve.fi to get back 3CRV\n    // (set stableForAddLiquidity for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    PickleJar public immutable pickleJar;\n    PickleMasterChef public pickleMasterChef;\n    uint256 public poolId = 14;\n\n    IStableSwap3Pool public stableSwap3Pool;\n    address public stableForAddLiquidity;\n\n    constructor(\n        address _want,\n        address _p3crv,\n        address _pickle,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        address _stableForAddLiquidity,\n        PickleMasterChef _pickleMasterChef,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _vaultManager,\n        address _router\n    )\n        public\n        BaseStrategy(_controller, _vaultManager, _want, _weth, _router)\n    {\n        p3crv = _p3crv;\n        pickle = _pickle;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        pickleMasterChef = _pickleMasterChef;\n        stableForAddLiquidity = _stableForAddLiquidity;\n        stableSwap3Pool = _stableSwap3Pool;\n        pickleJar = PickleJar(_p3crv);\n        IERC20(_want).safeApprove(_p3crv, type(uint256).max);\n        IERC20(_p3crv).safeApprove(address(_pickleMasterChef), type(uint256).max);\n        IERC20(_pickle).safeApprove(address(_router), type(uint256).max);\n    }\n\n    function setStableForLiquidity(address _stableForAddLiquidity) external onlyAuthorized {\n        stableForAddLiquidity = _stableForAddLiquidity;\n    }\n\n    function setPickleMasterChef(PickleMasterChef _pickleMasterChef) external onlyAuthorized {\n        pickleMasterChef = _pickleMasterChef;\n        IERC20(p3crv).safeApprove(address(_pickleMasterChef), 0);\n        IERC20(p3crv).safeApprove(address(_pickleMasterChef), type(uint256).max);\n    }\n\n    function setPoolId(uint _poolId) external onlyAuthorized {\n        poolId = _poolId;\n    }\n\n    function _deposit() internal override {\n        uint _wantBal = balanceOfWant();\n        if (_wantBal > 0) {\n            // deposit 3crv to pickleJar\n            pickleJar.depositAll();\n        }\n\n        uint _p3crvBal = IERC20(p3crv).balanceOf(address(this));\n        if (_p3crvBal > 0) {\n            // stake p3crv to pickleMasterChef\n            pickleMasterChef.deposit(poolId, _p3crvBal);\n        }\n    }\n\n    function _claimReward() internal {\n        pickleMasterChef.withdraw(poolId, 0);\n    }\n\n    function _withdrawAll() internal override {\n        (uint amount,) = pickleMasterChef.userInfo(poolId, address(this));\n        pickleMasterChef.withdraw(poolId, amount);\n        pickleJar.withdrawAll();\n    }\n\n    // to get back want (3CRV)\n    function _addLiquidity() internal {\n        // 0: DAI, 1: USDC, 2: USDT\n        uint[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        // add_liquidity(uint[3] calldata amounts, uint min_mint_amount)\n        stableSwap3Pool.add_liquidity(amounts, 1);\n    }\n\n    function _harvest() internal override {\n        _claimReward();\n        uint256 _remainingWeth = _payHarvestFees(pickle);\n\n        if (_remainingWeth > 0) {\n            _swapTokens(weth, stableForAddLiquidity, _remainingWeth);\n            _addLiquidity();\n\n            if (balanceOfWant() > 0) {\n                _deposit(); // auto re-invest\n            }\n        }\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        // unstake p3crv from pickleMasterChef\n        uint _ratio = pickleJar.getRatio();\n        _amount = _amount.mul(1e18).div(_ratio);\n        (uint _stakedAmount,) = pickleMasterChef.userInfo(poolId, address(this));\n        if (_amount > _stakedAmount) {\n            _amount = _stakedAmount;\n        }\n        uint _before = pickleJar.balanceOf(address(this));\n        pickleMasterChef.withdraw(poolId, _amount);\n        uint _after = pickleJar.balanceOf(address(this));\n        _amount = _after.sub(_before);\n\n        // withdraw 3crv from pickleJar\n        pickleJar.withdraw(_amount);\n    }\n\n    function balanceOfPool() public view override returns (uint) {\n        uint p3crvBal = pickleJar.balanceOf(address(this));\n        (uint amount,) = pickleMasterChef.userInfo(poolId, address(this));\n        return p3crvBal.add(amount).mul(pickleJar.getRatio()).div(1e18);\n    }\n}\n"
    },
    "contracts/interfaces/PickleJar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface PickleJar {\n    function balanceOf(address account) external view returns (uint);\n    function balance() external view returns (uint);\n    function available() external view returns (uint);\n    function depositAll() external;\n    function deposit(uint _amount) external;\n    function withdrawAll() external;\n    function withdraw(uint _shares) external;\n    function getRatio() external view returns (uint);\n}\n"
    },
    "contracts/interfaces/PickleMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface PickleMasterChef {\n    function deposit(uint _poolId, uint _amount) external;\n    function withdraw(uint _poolId, uint _amount) external;\n    function pendingPickle(uint _pid, address _user) external view returns (uint);\n    function userInfo(uint _pid, address _user) external view returns (uint amount, uint rewardDebt);\n    function emergencyWithdraw(uint _pid) external;\n}\n"
    },
    "contracts/metavault/mock/MockPickleJar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/PickleJar.sol\";\nimport \"./MockERC20.sol\";\n\ncontract MockPickleJar is MockERC20 {\n    IERC20 public t3crv;\n    IERC20 public lpToken;\n\n    constructor(IERC20 _t3crv) public MockERC20(\"pickling Curve.fi DAI/USDC/USDT\", \"p3Crv\", 18) {\n        t3crv = _t3crv;\n    }\n\n    function balance() public view returns (uint) {\n        return t3crv.balanceOf(address(this));\n    }\n\n    function available() external view returns (uint) {\n        return balance() * 9500 / 10000;\n    }\n\n    function depositAll() external {\n        deposit(t3crv.balanceOf(msg.sender));\n    }\n\n    function deposit(uint _amount) public {\n        t3crv.transferFrom(msg.sender, address(this), _amount);\n        uint256 shares = _amount * 1000000000000000000 / getRatio();\n        _mint(msg.sender, shares);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    function withdraw(uint _shares) public {\n        uint256 r = _shares * getRatio() / 1000000000000000000;\n        _burn(msg.sender, _shares);\n        t3crv.transfer(msg.sender, r);\n    }\n\n    function getRatio() public pure returns (uint) {\n        return 1010000000000000000; // +1%\n    }\n}\n"
    },
    "contracts/metavault/mock/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ncontract MockERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    address private _owner;\n\n    uint internal _totalSupply;\n\n    mapping(address => uint)                   private _balance;\n    mapping(address => mapping(address => uint)) private _allowance;\n\n    modifier _onlyOwner_() {\n        require(msg.sender == _owner, \"ERR_NOT_OWNER\");\n        _;\n    }\n\n    event Approval(address indexed src, address indexed dst, uint amt);\n    event Transfer(address indexed src, address indexed dst, uint amt);\n\n    // Math\n    function add(uint a, uint b) internal pure returns (uint c) {\n        require((c = a + b) >= a);\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require((c = a - b) <= a);\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _owner = msg.sender;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function _move(address src, address dst, uint amt) internal {\n        require(_balance[src] >= amt, \"!bal\");\n        _balance[src] = sub(_balance[src], amt);\n        _balance[dst] = add(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint amt) internal {\n        _move(from, address(this), amt);\n    }\n\n    function _mint(address dst, uint amt) internal {\n        _balance[dst] = add(_balance[dst], amt);\n        _totalSupply = add(_totalSupply, amt);\n        emit Transfer(address(0), dst, amt);\n    }\n\n    function _burn(address dst, uint amt) internal {\n        _balance[dst] = sub(_balance[dst], amt);\n        _totalSupply = sub(_totalSupply, amt);\n        emit Transfer(dst, address(0), amt);\n    }\n\n    function allowance(address src, address dst) external view returns (uint) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) public view returns (uint) {\n        return _balance[whom];\n    }\n\n    function faucet(uint256 amt) public returns (bool) {\n        _mint(msg.sender, amt);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint amt) external returns (bool) {\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function mint(address dst, uint256 amt) public _onlyOwner_ returns (bool) {\n        _mint(dst, amt);\n        return true;\n    }\n\n    function burn(uint amt) public returns (bool) {\n        require(_balance[msg.sender] >= amt, \"!bal\");\n        _burn(msg.sender, amt);\n        return true;\n    }\n\n    function transfer(address dst, uint amt) external returns (bool) {\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint amt) external returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"!spender\");\n        _move(src, dst, amt);\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(- 1)) {\n            _allowance[src][msg.sender] = sub(_allowance[src][msg.sender], amt);\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/metavault/mock/MockStableSwap3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../IStableSwap3Pool.sol\";\n\ncontract MockStableSwap3Pool is IStableSwap3Pool {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    // DAI, USDC, USDT\n    uint[3] public RATE = [10020, 9995, 9990];\n    uint[3] public PRECISION_MUL = [1, 1000000000000, 1000000000000];\n\n    IERC20[3] public inputTokens; // DAI, USDC, USDT\n    IERC20 public token3CRV; // 3Crv\n\n    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV) public {\n        inputTokens[0] = _tokenDAI;\n        inputTokens[1] = _tokenUSDC;\n        inputTokens[2] = _tokenUSDT;\n        token3CRV = _token3CRV;\n    }\n\n    function get_virtual_price() external override view returns (uint) {\n        return RATE[0].add(RATE[1]).add(RATE[2]).mul(1e18).div(30000);\n    }\n\n    function balances(uint _index) external override view returns (uint) {\n        return inputTokens[_index].balanceOf(address(this));\n    }\n\n    function get_dy(int128 i, int128 j, uint dx) public override view returns (uint) {\n        return dx.mul(RATE[uint8(i)]).mul(PRECISION_MUL[uint8(i)]).div(RATE[uint8(j)]).div(PRECISION_MUL[uint8(j)]);\n    }\n\n    function exchange(int128 i, int128 j, uint dx, uint min_dy) external override {\n        uint dy = get_dy(i, j, dx);\n        require(dy >= min_dy, \"below min_dy\");\n        inputTokens[uint8(i)].safeTransferFrom(msg.sender, address(this), dx);\n        inputTokens[uint8(j)].safeTransfer(msg.sender, dy);\n    }\n\n    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external override {\n        uint _shareAmount = 0;\n        for (uint8 i = 0; i < 3; ++i) {\n            _shareAmount = _shareAmount.add(amounts[i].mul(RATE[i]).mul(PRECISION_MUL[i]).div(10000));\n        }\n        require(_shareAmount >= min_mint_amount, \"below min_mint_amount\");\n        token3CRV.safeTransfer(msg.sender, _shareAmount);\n    }\n\n    function remove_liquidity(uint, uint[3] calldata) external override {\n        require(false, \"Not implemented\");\n    }\n\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external override {\n        uint _outputAmount = calc_withdraw_one_coin(_token_amount, i);\n        require(_outputAmount >= min_amount, \"below min_amount\");\n        token3CRV.safeTransferFrom(msg.sender, address(this), _token_amount);\n        inputTokens[uint8(i)].safeTransfer(msg.sender, _outputAmount);\n    }\n\n    function calc_token_amount(uint[3] calldata amounts, bool) public override view returns (uint) {\n        uint _shareAmount = 0;\n        for (uint8 i = 0; i < 3; ++i) {\n            _shareAmount = _shareAmount.add(amounts[i].mul(RATE[i]).mul(PRECISION_MUL[i]).div(10000));\n        }\n        return _shareAmount;\n    }\n\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) public override view returns (uint) {\n        return _token_amount.mul(10000).div(RATE[uint8(i)]).div(PRECISION_MUL[uint8(i)]);\n    }\n}\n"
    },
    "contracts/metavault/mock/MockzpaToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../interfaces/Stabilize.sol\";\n\ncontract MockzpaToken is ERC20, IZPAToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\n    uint256 constant divisionFactor = 100000;\n\n    address public override underlyingAsset;\n    uint256 public override initialFee = 1000; // 1000 = 1%, 100000 = 100%, max fee restricted in contract is 10%\n    uint256 public override endFee = 100; // 100 = 0.1%\n    uint256 public override feeDuration = 604800; // The amount of seconds it takes from the initial to end fee\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 depositTime; // The time the user made a deposit, every deposit resets the time\n    }\n\n    mapping(address => UserInfo) private userInfo;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _underlyingAsset\n    )\n        public\n        ERC20(_name, _symbol)\n    {\n        underlyingAsset = _underlyingAsset;\n    }\n\n    function deposit(uint256 _amount) external override {\n        uint256 _toMint = _amount.mul(1e18).div(pricePerToken());\n        IERC20(underlyingAsset).safeTransferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, _toMint);\n        userInfo[_msgSender()].depositTime = block.timestamp; // Update the deposit time\n    }\n\n    function redeem(uint256 _amount) external override {\n        uint256 _underlyingAmount = _amount.mul(pricePerToken()).div(1e18);\n        _burn(msg.sender, _amount);\n\n        // Pay fee upon withdrawing\n        if (userInfo[_msgSender()].depositTime == 0) {\n            // The user has never deposited here\n            userInfo[_msgSender()].depositTime = block.timestamp; // Give them the max fee\n        }\n\n        uint256 feeSubtraction = initialFee.sub(endFee).mul(block.timestamp.sub(userInfo[_msgSender()].depositTime)).div(feeDuration);\n        if (feeSubtraction > initialFee.sub(endFee)) {\n            // Cannot reduce fee more than this\n            feeSubtraction = initialFee.sub(endFee);\n        }\n        uint256 fee = initialFee.sub(feeSubtraction);\n        fee = _underlyingAmount.mul(fee).div(divisionFactor);\n        _underlyingAmount = _underlyingAmount.sub(fee);\n\n        // Now withdraw this amount to the user and send fee to treasury\n        IERC20(underlyingAsset).safeTransfer(msg.sender, _underlyingAmount);\n        IERC20(underlyingAsset).safeTransfer(DEAD, fee);\n    }\n\n    function pricePerToken() public view override returns (uint256) {\n        return 2e18;\n    }\n}\n"
    },
    "contracts/metavault/mock/MockStabilizePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../interfaces/Stabilize.sol\";\n\ncontract MockStabilizePool is IZPAPool {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 public lpToken;\n    IERC20 public rewardToken;\n    uint256 public rewardRate;\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n        uint256 unclaimedReward;\n    }\n\n    mapping(uint256 => mapping(address => UserInfo)) private userInfo;\n    mapping(uint256 => address) public override poolTokenAddress;\n\n    constructor(\n        address _lpToken,\n        address _rewardToken,\n        uint256 _rewardRate\n    ) public {\n        lpToken = IERC20(_lpToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardRate = _rewardRate;\n    }\n\n    function deposit(uint256 _pid, uint256 _amount) external override {\n        userInfo[_pid][msg.sender].amount = userInfo[_pid][msg.sender].amount.add(_amount);\n        lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function withdraw(uint256 _pid, uint256 _amount) public override {\n        userInfo[_pid][msg.sender].amount = userInfo[_pid][msg.sender].amount.sub(_amount);\n        lpToken.safeTransfer(msg.sender, _amount);\n    }\n\n    function exit(uint256 _pid, uint256 _amount) external override {\n        withdraw(_pid, _amount);\n        getReward(_pid);\n    }\n\n    function getReward(uint256 _pid) public override {\n        uint256 _amount = rewardEarned(_pid, msg.sender);\n        rewardToken.safeTransfer(msg.sender, _amount);\n    }\n\n    function rewardEarned(uint256 _pid, address _user) public view override returns (uint256) {\n        return poolBalance(_pid, _user).mul(rewardRate).div(1000);\n    }\n\n    function poolBalance(uint256 _pid, address _user) public view override returns (uint256) {\n        return userInfo[_pid][_user].amount;\n    }\n}\n"
    },
    "contracts/metavault/yAxisMetaVaultHarvester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./IController.sol\";\nimport \"./IVaultManager.sol\";\n\n/**\n * @title yAxisMetaVaultHarvester\n * @notice This contract is to be used as a central point to call\n * harvest on all strategies for any given token. It has its own\n * permissions for harvesters (set by the strategist or governance).\n */\ncontract yAxisMetaVaultHarvester { // solhint-disable-line contract-name-camelcase\n    using SafeMath for uint256;\n\n    IVaultManager public vaultManager;\n    IController public controller;\n\n    struct Strategy {\n        uint256 timeout;\n        uint256 lastCalled;\n        address[] addresses;\n    }\n\n    mapping(address => Strategy) public strategies;\n    mapping(address => bool) public isHarvester;\n\n    /**\n     * @notice Logged when a controller is set\n     */\n    event ControllerSet(address indexed controller);\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(\n        address indexed controller,\n        address indexed strategy\n    );\n\n    /**\n     * @notice Logged when a harvester is set\n     */\n    event HarvesterSet(address indexed harvester, bool status);\n\n    /**\n     * @notice Logged when a strategy is added for a token\n     */\n    event StrategyAdded(address indexed token, address indexed strategy, uint256 timeout);\n\n    /**\n     * @notice Logged when a strategy is removed for a token\n     */\n    event StrategyRemoved(address indexed token, address indexed strategy, uint256 timeout);\n\n    /**\n     * @notice Logged when a vault manger is set\n     */\n    event VaultManagerSet(address indexed vaultManager);\n\n    /**\n     * @param _vaultManager The address of the yAxisMetaVaultManager contract\n     * @param _controller The address of the controller\n     */\n    constructor(address _vaultManager, address _controller) public {\n        vaultManager = IVaultManager(_vaultManager);\n        controller = IController(_controller);\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy to the rotation for a given token and sets a timeout\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _token,\n        address _strategy,\n        uint256 _timeout\n    ) external onlyStrategist {\n        strategies[_token].addresses.push(_strategy);\n        strategies[_token].timeout = _timeout;\n        emit StrategyAdded(_token, _strategy, _timeout);\n    }\n\n    /**\n     * @notice Removes a strategy from the rotation for a given token and sets a timeout\n     * @param _token The address of the token\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _token,\n        address _strategy,\n        uint256 _timeout\n    ) external onlyStrategist {\n        uint256 tail = strategies[_token].addresses.length;\n        uint256 index;\n        bool found;\n        for (uint i; i < tail; i++) {\n            if (strategies[_token].addresses[i] == _strategy) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n        require(found, \"!found\");\n        strategies[_token].addresses[index] = strategies[_token].addresses[tail.sub(1)];\n        strategies[_token].addresses.pop();\n        strategies[_token].timeout = _timeout;\n        emit StrategyRemoved(_token, _strategy, _timeout);\n    }\n\n    /**\n     * @notice Sets the address of the controller\n     * @param _controller The address of the controller\n     */\n    function setController(IController _controller) external onlyStrategist {\n        controller = _controller;\n        emit ControllerSet(address(_controller));\n    }\n\n    /**\n     * @notice Sets the status of a harvester address to be able to call harvest functions\n     * @param _harvester The address of the harvester\n     * @param _status The status to allow the harvester to harvest\n     */\n    function setHarvester(address _harvester, bool _status) public onlyStrategist {\n        isHarvester[_harvester] = _status;\n        emit HarvesterSet(_harvester, _status);\n    }\n\n    /**\n     * @notice Sets the address of the vault manager contract\n     * @param _vaultManager The address of the vault manager\n     */\n    function setVaultManager(address _vaultManager) external onlyStrategist {\n        vaultManager = IVaultManager(_vaultManager);\n        emit VaultManagerSet(_vaultManager);\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST|HARVESTER)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Harvests a given strategy on the provided controller\n     * @dev This function ignores the timeout\n     * @param _controller The address of the controller\n     * @param _strategy The address of the strategy\n     */\n    function harvest(\n        IController _controller,\n        address _strategy\n    ) public onlyHarvester {\n        _controller.harvestStrategy(_strategy);\n        emit Harvest(address(_controller), _strategy);\n    }\n\n    /**\n     * @notice Harvests the next available strategy for a given token and\n     * rotates the strategies\n     * @param _token The address of the token\n     */\n    function harvestNextStrategy(address _token) external {\n        require(canHarvest(_token), \"!canHarvest\");\n        address strategy = strategies[_token].addresses[0];\n        harvest(controller, strategy);\n        uint256 k = strategies[_token].addresses.length;\n        if (k > 1) {\n            address[] memory _strategies = new address[](k);\n            for (uint i; i < k-1; i++) {\n                _strategies[i] = strategies[_token].addresses[i+1];\n            }\n            _strategies[k-1] = strategy;\n            strategies[_token].addresses = _strategies;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        strategies[_token].lastCalled = block.timestamp;\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the addresses of the strategies for a given token\n     * @param _token The address of the token\n     */\n    function strategyAddresses(address _token) external view returns (address[] memory) {\n        return strategies[_token].addresses;\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the availability of a token's strategy to be harvested\n     * @param _token The address of the token\n     */\n    function canHarvest(address _token) public view returns (bool) {\n        Strategy storage strategy = strategies[_token];\n        if (strategy.addresses.length == 0 ||\n            // solhint-disable-next-line not-rely-on-time\n            strategy.lastCalled > block.timestamp.sub(strategy.timeout)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyHarvester() {\n        require(isHarvester[msg.sender], \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == vaultManager.strategist()\n             || msg.sender == vaultManager.governance(),\n             \"!strategist\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/metavault/mock/MockUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ninterface IUniswapRouter {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n}\n\ncontract MockUniswapRouter is IUniswapRouter {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 univ2LpToken;\n\n    constructor(IERC20 _univ2LpToken) public {\n        univ2LpToken = _univ2LpToken;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) public override returns (uint256[] memory amounts) {\n        return _swap(amountIn, amountOutMin, path, to, deadline);\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        return _swap(amountIn, amountOutMin, path, to, deadline);\n    }\n\n    function _swap(\n        uint256 amountIn,\n        uint256,\n        address[] calldata path,\n        address to,\n        uint256\n    ) internal returns (uint256[] memory amounts) {\n        uint256 amountOut = amountIn.mul(1); // assume 1 INPUT -> 1 OUTPUT\n        IERC20 inputToken = IERC20(path[0]);\n        IERC20 outputToken = IERC20(path[path.length - 1]);\n        inputToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        outputToken.safeTransfer(to, amountOut);\n        amounts = new uint256[](2);\n        amounts[0] = amountIn;\n        amounts[1] = amountOut;\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint,\n        uint,\n        address to,\n        uint\n    ) external override returns (uint amountA, uint amountB, uint liquidity) {\n        amountA = (amountADesired < amountBDesired) ? amountADesired : amountBDesired;\n        amountB = amountA;\n        liquidity = amountA;\n        IERC20(tokenA).safeTransferFrom(msg.sender, address(this), amountA);\n        IERC20(tokenB).safeTransferFrom(msg.sender, address(this), amountB);\n        univ2LpToken.safeTransfer(to, liquidity); // 1A + 1B -> 1LP\n    }\n}\n"
    },
    "contracts/metavault/mock/MockDRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockDRewards {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public lpToken;\n    IERC20 public rewardToken;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 rewardRate; // over 1000\n\n    constructor(\n        address _lpToken,\n        address _rewardToken,\n        uint256 _rewardRate\n    ) public {\n        lpToken = IERC20(_lpToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardRate = _rewardRate;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return balanceOf(account).mul(rewardRate).div(1000);\n    }\n\n    function stake(uint256 amount) public {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        lpToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        lpToken.safeTransfer(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            if (reward > rewardToken.balanceOf(address(this))) {\n                reward = rewardToken.balanceOf(address(this));\n            }\n            rewardToken.safeTransfer(msg.sender, reward);\n        }\n    }\n}\n"
    },
    "contracts/metavault/mock/MockDErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockDErc20 is ERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public underlying;\n\n    constructor(string memory name, string memory symbol, IERC20 _underlying) public ERC20(name, symbol) {\n        underlying = _underlying;\n    }\n\n    function getExchangeRate() public pure returns (uint256) {\n        return 2e18; // 1 dDAI = 2 DAI\n    }\n\n    function getTokenBalance(address _account) external view returns (uint256) {\n        return balanceOf(_account).mul(getExchangeRate()).div(1e18);\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        uint256 _toMint = _amount.mul(1e18).div(getExchangeRate());\n        underlying.safeTransferFrom(msg.sender, address(this), _amount);\n        _mint(_account, _toMint);\n    }\n\n    function redeem(address _account, uint256 _amount) external {\n        uint256 _underlyingAmount = _amount.mul(getExchangeRate()).div(1e18);\n        _burn(_account, _amount);\n        underlying.safeTransfer(msg.sender, _underlyingAmount);\n    }\n}\n"
    },
    "contracts/metavault/mock/MockCurveMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../interfaces/Gauge.sol\";\n\ncontract MockCurveMinter is Mintr {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 crv;\n\n    constructor(IERC20 _crv) public {\n        crv = _crv;\n    }\n\n    function mint(address) external override {\n        uint _bal = crv.balanceOf(address(this));\n        crv.safeTransfer(msg.sender, _bal.div(10)); // always mint 10% amount of balance\n    }\n}\n"
    },
    "contracts/metavault/mock/MockCurveGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../interfaces/Gauge.sol\";\n\ncontract MockCurveGauge is Gauge {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 want;\n\n    mapping(address => uint) public amounts;\n\n    constructor(IERC20 _want) public {\n        want = _want;\n    }\n\n    function deposit(uint _amount) external override {\n        want.safeTransferFrom(msg.sender, address(this), _amount);\n        amounts[msg.sender] = amounts[msg.sender].add(_amount);\n    }\n\n    function balanceOf(address _account) external override view returns (uint) {\n        return amounts[_account];\n    }\n\n    function claimable_tokens(address _account) external override view returns (uint) {\n        return amounts[_account].div(10); // always return 10% of staked\n    }\n\n    function withdraw(uint _amount) external override {\n        want.safeTransfer(msg.sender, _amount);\n        amounts[msg.sender] = amounts[msg.sender].sub(_amount);\n    }\n}\n"
    },
    "contracts/metavault/mock/MockPickleMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockPickleMasterChef {\n    IERC20 public pickleToken;\n    IERC20 public lpToken;\n\n    struct UserInfo {\n        uint amount; // How many LP tokens the user has provided.\n        uint rewardDebt; // Reward debt. See explanation below.\n    }\n\n    mapping(uint => mapping(address => UserInfo)) public userInfo;\n\n    constructor(IERC20 _pickleToken, IERC20 _lpToken) public {\n        pickleToken = _pickleToken;\n        lpToken = _lpToken;\n    }\n\n    function deposit(uint _pid, uint _amount) external {\n        lpToken.transferFrom(msg.sender, address(this), _amount);\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pickleToken.transfer(msg.sender, user.amount / 10); // always get 10% of deposited amount\n        user.amount = user.amount + _amount;\n    }\n\n    function withdraw(uint _pid, uint _amount) external {\n        lpToken.transfer(msg.sender, _amount);\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pickleToken.transfer(msg.sender, user.amount / 10); // always get 10% of deposited amount\n        user.amount = user.amount - _amount;\n    }\n\n    function pendingPickle(uint, address) external view returns (uint) {\n        return pickleToken.balanceOf(address(this)) / 10;\n    }\n\n    function emergencyWithdraw(uint _pid) external {\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        lpToken.transfer(msg.sender, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n    }\n}\n"
    },
    "contracts/metavault/strategies/StrategyDforce.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/DForce.sol\";\nimport \"../IConverter.sol\";\nimport \"./BaseStrategy.sol\";\n\ncontract StrategyDforce is BaseStrategy {\n    address public immutable dToken;\n    address public immutable pool;\n    address public immutable DF;\n    IConverter public converter;\n\n    constructor(\n        address _underlying,\n        address _dToken,\n        address _pool,\n        address _DF,\n        address _converter,\n        address _controller,\n        address _vaultManager,\n        address _weth,\n        address _router\n    )\n        public\n        BaseStrategy(_controller, _vaultManager, _underlying, _weth, _router)\n    {\n        dToken = _dToken;\n        pool = _pool;\n        DF = _DF;\n        converter = IConverter(_converter);\n        IERC20(_DF).safeApprove(address(_router), type(uint256).max);\n        IERC20(_underlying).safeApprove(address(_converter), type(uint256).max);\n        IERC20(_underlying).safeApprove(_dToken, type(uint256).max);\n        IERC20(_dToken).safeApprove(_pool, type(uint256).max);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return (dRewards(pool).balanceOf(address(this)))\n            .mul(dERC20(dToken).getExchangeRate())\n            .div(1e18)\n            .add(balanceOfdToken());\n    }\n\n    function balanceOfdToken() public view returns (uint256) {\n        return dERC20(dToken).getTokenBalance(address(this));\n    }\n\n    function _deposit() internal override {\n        uint256 _amount = balanceOfWant();\n        if (_amount > 0) {\n            dERC20(dToken).mint(address(this), _amount);\n        }\n        uint256 _dToken = IERC20(dToken).balanceOf(address(this));\n        if (_dToken > 0) {\n            dRewards(pool).stake(_dToken);\n        }\n    }\n\n    function _harvest() internal override {\n        dRewards(pool).getReward();\n        uint256 _remainingWeth = _payHarvestFees(DF);\n\n        if (_remainingWeth > 0) {\n            _swapTokens(weth, want, _remainingWeth);\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        _amount = _amount.mul(1e18).div(dERC20(dToken).getExchangeRate());\n        uint256 _before = IERC20(dToken).balanceOf(address(this));\n        dRewards(pool).withdraw(_amount);\n        uint256 _after = IERC20(dToken).balanceOf(address(this));\n        _amount = _after.sub(_before);\n        dERC20(dToken).redeem(address(this), _amount);\n        _amount = balanceOfWant();\n        if (_amount > 0) {\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    function _withdrawAll() internal override {\n        dRewards(pool).exit();\n        uint256 _amount = IERC20(dToken).balanceOf(address(this));\n        if (_amount > 0) {\n            dERC20(dToken).redeem(address(this), _amount);\n            _amount = balanceOfWant();\n            _convert(want, _vaultWant(), _amount);\n        }\n    }\n\n    function _convert(address _from, address _to, uint256 _amount) internal {\n        require(converter.convert_rate(_from, _to, _amount) > 0, \"!convert_rate\");\n        IERC20(_from).safeTransfer(address(converter), _amount);\n        converter.convert(_from, _to, _amount);\n    }\n}\n"
    },
    "contracts/interfaces/DForce.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface dRewards {\n    function withdraw(uint) external;\n    function getReward() external;\n    function stake(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function exit() external;\n}\n\ninterface dERC20 {\n  function mint(address, uint256) external;\n  function redeem(address, uint) external;\n  function getTokenBalance(address) external view returns (uint);\n  function getExchangeRate() external view returns (uint);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}