{
  "language": "Solidity",
  "sources": {
    "contracts/governance/interfaces/IRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IRewards {\n    function balanceOf(address) external view returns (uint256);\n    function earned(address) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/governance/YaxisVotePower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IRewards.sol\";\nimport \"./interfaces/IUniswapV2Pair.sol\";\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVotePower is IVoteProxy {\n    using SafeMath for uint256;\n\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant override decimals = uint8(18);\n\n    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;\n    IERC20 public immutable yaxis;\n    IRewards public immutable rewardsYaxis;\n    IRewards public immutable rewardsYaxisEth;\n\n    constructor(\n        address _yaxis,\n        address _rewardsYaxis,\n        address _rewardsYaxisEth,\n        address _yaxisEthUniswapV2Pair\n    )\n        public\n    {\n        yaxis = IERC20(_yaxis);\n        rewardsYaxis = IRewards(_rewardsYaxis);\n        rewardsYaxisEth = IRewards(_rewardsYaxisEth);\n        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);\n    }\n\n    function totalSupply()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return sqrt(yaxis.totalSupply());\n    }\n\n    function balanceOf(\n        address _voter\n    )\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);\n        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\n        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();\n        _supply = _supply == 0\n            ? 1e18\n            : _supply;\n        uint256 _lpStakingYax = _yaxReserves\n            .mul(_stakeAmount)\n            .div(_supply)\n            .add(rewardsYaxisEth.earned(_voter));\n        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)\n            .add(rewardsYaxis.earned(_voter));\n        _balance = sqrt(\n            yaxis.balanceOf(_voter)\n                .add(_lpStakingYax)\n                .add(_rewardsYaxisAmount)\n        );\n    }\n\n    function sqrt(\n        uint256 x\n    )\n        private\n        pure\n        returns (uint256 y)\n    {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        y = y * (10 ** 9);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/governance/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IUniswapV2Pair is IERC20 {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n"
    },
    "contracts/governance/interfaces/IVoteProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IVoteProxy {\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _voter) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/governance/YaxisVoteProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IVoteProxy.sol\";\n\ncontract YaxisVoteProxy {\n    IVoteProxy public voteProxy;\n    address public governance;\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    function name() external pure returns (string memory) {\n        return \"YAXIS Vote Power\";\n    }\n\n    function symbol() external pure returns (string memory) {\n        return \"YAX VP\";\n    }\n\n    function decimals() external view returns (uint8) {\n        return voteProxy.decimals();\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return voteProxy.totalSupply();\n    }\n\n    function balanceOf(address _voter) external view returns (uint256) {\n        return voteProxy.balanceOf(_voter);\n    }\n\n    function setVoteProxy(IVoteProxy _voteProxy) external {\n        require(msg.sender == governance, \"!governance\");\n        voteProxy = _voteProxy;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n\n\n/**\n * This function allows governance to take unsupported tokens out of the contract.\n * This is in an effort to make someone whole, should they seriously mess up.\n * There is no guarantee governance will vote to return these.\n * It also allows for removal of airdropped tokens.\n */\n    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {\n        require(msg.sender == governance, \"!governance\");\n        _token.transfer(to, amount);\n    }\n}\n"
    },
    "contracts/v3/VaultHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILiquidityGaugeV2.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title VaultHelper\n * @notice The VaultHelper acts as a single contract that users may set\n * token approvals on for any token of any vault.\n * @dev This contract has no state and could be deployed by anyone if\n * they didn't trust the original deployer.\n */\ncontract VaultHelper {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Deposits into the specified vault and stakes in the gauge\n     * @dev Users must approve the vault helper to spend their token\n     * @param _vault The address of the vault\n     * @param _amount The amount of tokens to deposit\n     */\n    function depositVault(\n        address _vault,\n        uint256 _amount\n    )\n        external\n    {\n        require(_amount > 0, \"!_amount\");\n        address _token = IVault(_vault).getToken();\n        address _vaultToken = IVault(_vault).getLPToken();\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(_token).safeApprove(_vault, 0);\n        IERC20(_token).safeApprove(_vault, _amount);\n        uint256 _shares = IVault(_vault).deposit(_amount);\n        address _gauge = IVault(_vault).gauge();\n        if (_gauge != address(0)) {\n            IERC20(_vaultToken).safeApprove(_gauge, 0);\n            IERC20(_vaultToken).safeApprove(_gauge, _shares);\n            ILiquidityGaugeV2(_gauge).deposit(_shares);\n            IERC20(_gauge).safeTransfer(msg.sender, _shares);\n        } else {\n            IERC20(_vaultToken).safeTransfer(msg.sender, _shares);\n        }\n    }\n\n    function withdrawVault(\n        address _vault,\n        uint256 _amount\n    )\n        external\n    {\n        address _gauge = IVault(_vault).gauge();\n        address _token = IVault(_vault).getToken();\n        address _vaultToken = IVault(_vault).getLPToken();\n        if (_gauge != address(0)) {\n            IERC20(_gauge).safeTransferFrom(msg.sender, address(this), _amount);\n            ILiquidityGaugeV2(_gauge).withdraw(_amount);\n            IVault(_vault).withdraw(IERC20(_vaultToken).balanceOf(address(this)));\n            IERC20(_token).safeTransfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        } else {\n            IERC20(_vaultToken).safeTransferFrom(msg.sender, address(this), _amount);\n            IVault(_vault).withdraw(_amount);\n            IERC20(_token).safeTransfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/v3/interfaces/ILiquidityGaugeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface ILiquidityGaugeV2 {\n    function set_approve_deposit(address, bool) external;\n    function deposit(uint256) external;\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/v3/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\n\ninterface IVault {\n    function available() external view returns (uint256);\n    function balance() external view returns (uint256);\n    function deposit(uint256 _amount) external returns (uint256);\n    function earn(address _strategy) external;\n    function gauge() external returns (address);\n    function getLPToken() external view returns (address);\n    function getPricePerFullShare() external view returns (uint256);\n    function getToken() external view returns (address);\n    function manager() external view returns (IManager);\n    function withdraw(uint256 _amount) external;\n    function withdrawAll() external;\n    function withdrawFee(uint256 _amount) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/v3/interfaces/IManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IManager {\n    function addVault(address) external;\n    function allowedControllers(address) external view returns (bool);\n    function allowedConverters(address) external view returns (bool);\n    function allowedStrategies(address) external view returns (bool);\n    function allowedVaults(address) external view returns (bool);\n    function controllers(address) external view returns (address);\n    function getHarvestFeeInfo() external view returns (address, address, uint256);\n    function getToken(address) external view returns (address);\n    function governance() external view returns (address);\n    function halted() external view returns (bool);\n    function harvester() external view returns (address);\n    function insuranceFee() external view returns (uint256);\n    function insurancePool() external view returns (address);\n    function insurancePoolFee() external view returns (uint256);\n    function pendingStrategist() external view returns (address);\n    function removeVault(address) external;\n    function stakingPool() external view returns (address);\n    function stakingPoolShareFee() external view returns (uint256);\n    function strategist() external view returns (address);\n    function treasury() external view returns (address);\n    function treasuryFee() external view returns (uint256);\n    function withdrawalProtectionFee() external view returns (uint256);\n    function yaxis() external view returns (address);\n}\n"
    },
    "contracts/v3/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IVaultToken.sol\";\nimport \"./interfaces/ExtendedIERC20.sol\";\n\n/**\n * @title Vault\n * @notice The vault is where users deposit and withdraw\n * like-kind assets that have been added by governance.\n */\ncontract Vault is IVault {\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX = 10000;\n\n    IManager public immutable override manager;\n    IERC20 public immutable token;\n    IVaultToken public immutable vaultToken;\n\n    // Strategist-updated variables\n    address public override gauge;\n    uint256 public min;\n    uint256 public totalDepositCap;\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n    event Earn(address indexed token, uint256 amount);\n\n    /**\n     * @param _depositToken The address of the deposit token of the vault\n     * @param _vaultToken The address of the share token for the vault\n     * @param _manager The address of the vault manager contract\n     */\n    constructor(\n        address _depositToken,\n        address _vaultToken,\n        address _manager\n    )\n        public\n    {\n        manager = IManager(_manager);\n        token = IERC20(_depositToken);\n        vaultToken = IVaultToken(_vaultToken);\n        min = 9500;\n        totalDepositCap = 10000000 ether;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the value of this vault's gauge\n     * @dev Allow to be unset with the zero address\n     * @param _gauge The address of the gauge\n     */\n    function setGauge(\n        address _gauge\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        gauge = _gauge;\n    }\n\n    /**\n     * @notice Sets the value for min\n     * @dev min is the minimum percent of funds to keep small withdrawals cheap\n     * @param _min The new min value\n     */\n    function setMin(\n        uint256 _min\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(_min <= MAX, \"!_min\");\n        min = _min;\n    }\n\n    /**\n     * @notice Sets the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(\n        uint256 _totalDepositCap\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn(\n        address _strategy\n    )\n        external\n        override\n        notHalted\n        onlyHarvester\n    {\n        require(manager.allowedStrategies(_strategy), \"!_strategy\");\n        IController _controller = IController(manager.controllers(address(this)));\n        if (_controller.investEnabled()) {\n            uint256 _balance = available();\n            token.safeTransfer(address(_controller), _balance);\n            _controller.earn(_strategy, address(token), _balance);\n            emit Earn(address(token), _balance);\n        }\n    }\n\n    /**\n     * USER-FACING FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits the given token into the vault\n     * @param _amount The amount of tokens to deposit\n     */\n     function deposit(\n        uint256 _amount\n     )\n        public\n        override\n        notHalted\n        returns (uint256 _shares)\n    {\n        require(_amount > 0, \"!_amount\");\n\n        uint256 _balance = balance();\n\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        _amount = token.balanceOf(address(this)).sub(_before);\n        uint256 _supply = IERC20(address(vaultToken)).totalSupply();\n\n        _amount = _normalizeDecimals(_amount);\n\n        if (_supply > 0) {\n            _amount = (_amount.mul(_supply)).div(_balance);\n        }\n\n        _shares = _amount;\n\n        require(_shares > 0, \"shares=0\");\n        require(_supply.add(_shares) <= totalDepositCap, \">totalDepositCap\");\n        vaultToken.mint(msg.sender, _shares);\n        emit Deposit(msg.sender, _shares);\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output token\n     * @param _shares The amount of shares to withdraw\n     */\n    function withdraw(\n        uint256 _shares\n    )\n        public\n        override\n    {\n        uint256 _amount = (balance().mul(_shares)).div(IERC20(address(vaultToken)).totalSupply());\n        vaultToken.burn(msg.sender, _shares);\n\n        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();\n        if (_withdrawalProtectionFee > 0) {\n            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);\n            _amount = _amount.sub(_withdrawalProtection);\n        }\n\n        uint256 _balance = token.balanceOf(address(this));\n        if (_balance < _amount) {\n            IController _controller = IController(manager.controllers(address(this)));\n            uint256 _toWithdraw = _amount.sub(_balance);\n            if (_controller.strategies() > 0) {\n                _controller.withdraw(address(token), _toWithdraw);\n            }\n            uint256 _after = token.balanceOf(address(this));\n            uint256 _diff = _after.sub(_balance);\n            if (_diff < _toWithdraw) {\n                _amount = _after;\n            }\n        }\n\n        token.safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     */\n    function withdrawAll()\n        external\n        override\n    {\n        withdraw(IERC20(address(vaultToken)).balanceOf(msg.sender));\n    }\n\n    /**\n     * VIEWS\n     */\n\n    /**\n     * @notice Returns the amount of tokens available to be sent to strategies\n     * @dev Custom logic in here for how much the vault allows to be borrowed\n     * @dev Sets minimum required on-hand to keep small withdrawals cheap\n     */\n    function available()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return token.balanceOf(address(this)).mul(min).div(MAX);\n    }\n\n    /**\n     * @notice Returns the total balance of the vault, including strategies\n     */\n    function balance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());\n    }\n\n    /**\n     * @notice Returns the balance of allowed tokens present on the vault only\n     */\n    function balanceOfThis()\n        public\n        view\n        returns (uint256)\n    {\n        return _normalizeDecimals(token.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Returns the rate of vault shares\n     */\n    function getPricePerFullShare()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _supply = IERC20(address(vaultToken)).totalSupply();\n        if (_supply > 0) {\n            return balance().mul(1e18).div(_supply);\n        } else {\n            return balance();\n        }\n    }\n\n    /**\n     * @notice Returns the deposit token for the vault\n     */\n    function getToken()\n        public\n        view\n        override\n        returns (address)\n    {\n        return address(token);\n    }\n\n    function getLPToken()\n        external\n        view\n        override\n        returns (address)\n    {\n        return address(vaultToken);\n    }\n\n    /**\n     * @notice Returns the fee for withdrawing the given amount\n     * @param _amount The amount to withdraw\n     */\n    function withdrawFee(\n        uint256 _amount\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);\n    }\n\n    function _normalizeDecimals(\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = uint256(ExtendedIERC20(address(token)).decimals());\n        if (_decimals < 18) {\n            _amount = _amount.mul(10**(18-_decimals));\n        }\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n"
    },
    "contracts/v3/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\n\ninterface IController {\n    function balanceOf() external view returns (uint256);\n    function converter(address _vault) external view returns (address);\n    function earn(address _strategy, address _token, uint256 _amount) external;\n    function investEnabled() external view returns (bool);\n    function harvestStrategy(address _strategy, uint256 _estimatedWETH, uint256 _estimatedYAXIS) external;\n    function manager() external view returns (IManager);\n    function strategies() external view returns (uint256);\n    function withdraw(address _token, uint256 _amount) external;\n    function withdrawAll(address _strategy, address _convert) external;\n}\n"
    },
    "contracts/v3/interfaces/IConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\n\ninterface IConverter {\n    function manager() external view returns (IManager);\n    function convert(\n        address _input,\n        address _output,\n        uint256 _inputAmount,\n        uint256 _estimatedOutput\n    ) external returns (uint256 _outputAmount);\n    function expected(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    ) external view returns (uint256 _outputAmount);\n}\n"
    },
    "contracts/v3/interfaces/IVaultToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IVaultToken {\n    function mint(address,uint256) external;\n    function burn(address,uint256) external;\n}\n"
    },
    "contracts/v3/interfaces/ExtendedIERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface ExtendedIERC20 {\n    function decimals() external view returns (uint8);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/v3/strategies/NativeStrategyCurve3Crv.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Gauge.sol\";\nimport \"../../interfaces/Balancer.sol\";\n\nimport \"../interfaces/ExtendedIERC20.sol\";\n\nimport \"./BaseStrategy.sol\";\n\ncontract NativeStrategyCurve3Crv is BaseStrategy {\n    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route\n    address public immutable crv;\n\n    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    Mintr public immutable crvMintr;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n    Gauge public immutable gauge; // 3Crv Gauge\n\n    constructor(\n        string memory _name,\n        address _want,\n        address _crv,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        Gauge _gauge,\n        Mintr _crvMintr,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _manager,\n        address _router\n    )\n        public\n        BaseStrategy(_name, _controller, _manager, _want, _weth, _router)\n    {\n        crv = _crv;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        stableSwap3Pool = _stableSwap3Pool;\n        gauge = _gauge;\n        crvMintr = _crvMintr;\n        IERC20(_want).safeApprove(address(_gauge), type(uint256).max);\n        IERC20(_crv).safeApprove(address(_router), type(uint256).max);\n        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n    }\n\n    function _deposit()\n        internal\n        override\n    {\n        uint256 _wantBal = balanceOfWant();\n        if (_wantBal > 0) {\n            // deposit [want] to Gauge\n            gauge.deposit(_wantBal);\n        }\n    }\n\n    function _claimReward()\n        internal\n    {\n        crvMintr.mint(address(gauge));\n    }\n\n    function _addLiquidity()\n        internal\n    {\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, 1);\n    }\n\n    function getMostPremium()\n        public\n        view\n        returns (address, uint256)\n    {\n        uint daiBalance = stableSwap3Pool.balances(0);\n        // USDC - Supports a change up to the 18 decimal standard\n        uint usdcBalance = stableSwap3Pool.balances(1).mul(10**18).div(10**(ExtendedIERC20(usdc).decimals()));\n        uint usdtBalance = stableSwap3Pool.balances(2).mul(10**12);\n\n        if (daiBalance <= usdcBalance && daiBalance <= usdtBalance) {\n            return (dai, 0);\n        }\n\n        if (usdcBalance <= daiBalance && usdcBalance <= usdtBalance) {\n            return (usdc, 1);\n        }\n\n        if (usdtBalance <= daiBalance && usdtBalance <= usdcBalance) {\n            return (usdt, 2);\n        }\n\n        return (dai, 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest(\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        internal\n        override\n    {\n        _claimReward();\n        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);\n\n        if (_remainingWeth > 0) {\n            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth, 1);\n            _addLiquidity();\n\n            _deposit();\n        }\n    }\n\n    function _withdrawAll()\n        internal\n        override\n    {\n        uint256 _bal = gauge.balanceOf(address(this));\n        _withdraw(_bal);\n    }\n\n    function _withdraw(\n        uint256 _amount\n    )\n        internal\n        override\n    {\n        gauge.withdraw(_amount);\n    }\n\n    function balanceOfPool()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return gauge.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/interfaces/Gauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Gauge {\n    function deposit(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function withdraw(uint) external;\n    function claimable_tokens(address) external view returns (uint);\n}\n\ninterface Mintr {\n    function mint(address) external;\n}\n"
    },
    "contracts/interfaces/Balancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface Balancer {\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountOut, uint spotPriceAfter);\n    function swapExactAmountOut(\n        address tokenIn,\n        uint maxAmountIn,\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountIn, uint spotPriceAfter);\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        uint minPoolAmountOut\n    ) external returns (uint poolAmountOut);\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint poolAmountIn,\n        uint minAmountOut\n    ) external returns (uint tokenAmountOut);\n}\n"
    },
    "contracts/v3/strategies/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IStableSwap3Pool.sol\";\nimport \"../interfaces/ISwap.sol\";\nimport \"../interfaces/IManager.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IController.sol\";\n\n/**\n * @title BaseStrategy\n * @notice The BaseStrategy is an abstract contract which all\n * yAxis strategies should inherit functionality from. It gives\n * specific security properties which make it hard to write an\n * insecure strategy.\n * @notice All state-changing functions implemented in the strategy\n * should be internal, since any public or externally-facing functions\n * are already handled in the BaseStrategy.\n * @notice The following functions must be implemented by a strategy:\n * - function _deposit() internal virtual;\n * - function _harvest() internal virtual;\n * - function _withdraw(uint256 _amount) internal virtual;\n * - function _withdrawAll() internal virtual;\n * - function balanceOfPool() public view override virtual returns (uint256);\n */\nabstract contract BaseStrategy is IStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\n\n    address public immutable override want;\n    address public immutable override weth;\n    address public immutable controller;\n    IManager public immutable override manager;\n    string public override name;\n    ISwap public override router;\n\n    /**\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _want The desired token of the strategy\n     * @param _weth The address of WETH\n     * @param _router The address of the router for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _controller,\n        address _manager,\n        address _want,\n        address _weth,\n        address _router\n    ) public {\n        name = _name;\n        want = _want;\n        controller = _controller;\n        manager = IManager(_manager);\n        weth = _weth;\n        router = ISwap(_router);\n        IERC20(_weth).safeApprove(address(_router), type(uint256).max);\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Approves a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    )\n        external\n    {\n        require(msg.sender == manager.governance(), \"!governance\");\n        _token.safeApprove(_spender, 0);\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Sets the address of the ISwap-compatible router\n     * @param _router The address of the router\n     */\n    function setRouter(\n        address _router\n    )\n        external\n    {\n        require(msg.sender == manager.governance(), \"!governance\");\n        router = ISwap(_router);\n        IERC20(weth).safeApprove(address(_router), 0);\n        IERC20(weth).safeApprove(address(_router), type(uint256).max);\n    }\n\n    /**\n     * CONTROLLER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits funds to the strategy's pool\n     */\n    function deposit()\n        external\n        override\n        onlyController\n    {\n        _deposit();\n    }\n\n    /**\n     * @notice Harvest funds in the strategy's pool\n     */\n    function harvest(\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        external\n        override\n        onlyController\n    {\n        _harvest(_estimatedWETH, _estimatedYAXIS);\n    }\n\n    /**\n     * @notice Sends stuck want tokens in the strategy to the controller\n     */\n    function skim()\n        external\n        override\n        onlyController\n    {\n        IERC20(want).safeTransfer(controller, balanceOfWant());\n    }\n\n    /**\n     * @notice Sends stuck tokens in the strategy to the controller\n     * @param _asset The address of the token to withdraw\n     */\n    function withdraw(\n        address _asset\n    )\n        external\n        override\n        onlyController\n    {\n        require(want != _asset, \"want\");\n\n        IERC20 _assetToken = IERC20(_asset);\n        uint256 _balance = _assetToken.balanceOf(address(this));\n        _assetToken.safeTransfer(controller, _balance);\n    }\n\n    /**\n     * @notice Initiated from a vault, withdraws funds from the pool\n     * @param _amount The amount of the want token to withdraw\n     */\n    function withdraw(\n        uint256 _amount\n    )\n        external\n        override\n        onlyController\n    {\n        uint256 _balance = balanceOfWant();\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        IERC20(want).safeTransfer(controller, _amount);\n    }\n\n    /**\n     * @notice Withdraws all funds from the strategy\n     */\n    function withdrawAll()\n        external\n        override\n        onlyController\n    {\n        _withdrawAll();\n\n        uint256 _balance = IERC20(want).balanceOf(address(this));\n\n        IERC20(want).safeTransfer(controller, _balance);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the strategy's balance of the want token plus the balance of pool\n     */\n    function balanceOf()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the balance of the pool\n     * @dev Must be implemented by the strategy\n     */\n    function balanceOfPool()\n        public\n        view\n        virtual\n        override\n        returns (uint256);\n\n    /**\n     * @notice Returns the balance of the want token on the strategy\n     */\n    function balanceOfWant()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    function _deposit()\n        internal\n        virtual;\n\n    function _harvest(\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        internal\n        virtual;\n\n    function _payHarvestFees(\n        address _poolToken,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        internal\n        returns (uint256 _wethBal)\n    {\n        uint256 _amount = IERC20(_poolToken).balanceOf(address(this));\n        _swapTokens(_poolToken, weth, _amount, _estimatedWETH);\n        _wethBal = IERC20(weth).balanceOf(address(this));\n\n        if (_wethBal > 0) {\n            // get all the necessary variables in a single call\n            (\n                address yaxis,\n                address treasury,\n                uint256 treasuryFee\n            ) = manager.getHarvestFeeInfo();\n\n            uint256 _fee;\n\n            // pay the treasury with YAX\n            if (treasuryFee > 0 && treasury != address(0)) {\n                _fee = _wethBal.mul(treasuryFee).div(ONE_HUNDRED_PERCENT);\n                _swapTokens(weth, yaxis, _fee, _estimatedYAXIS);\n                IERC20(yaxis).safeTransfer(treasury, IERC20(yaxis).balanceOf(address(this)));\n            }\n\n            // return the remaining WETH balance\n            _wethBal = IERC20(weth).balanceOf(address(this));\n        }\n    }\n\n    function _swapTokens(\n        address _input,\n        address _output,\n        uint256 _amount,\n        uint256 _expected\n    )\n        internal\n    {\n        address[] memory path = new address[](2);\n        path[0] = _input;\n        path[1] = _output;\n        router.swapExactTokensForTokens(\n            _amount,\n            _expected,\n            path,\n            address(this),\n            // The deadline is a hardcoded value that is far in the future.\n            1e10\n        );\n    }\n\n    function _withdraw(\n        uint256 _amount\n    )\n        internal\n        virtual;\n\n    function _withdrawAll()\n        internal\n        virtual;\n\n    function _withdrawSome(\n        uint256 _amount\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 _before = IERC20(want).balanceOf(address(this));\n        _withdraw(_amount);\n        uint256 _after = IERC20(want).balanceOf(address(this));\n        _amount = _after.sub(_before);\n\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"!controller\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/interfaces/IStableSwap3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IStableSwap3Pool {\n    function get_virtual_price() external view returns (uint);\n    function balances(uint) external view returns (uint);\n    function get_dy(int128 i, int128 j, uint dx) external view returns (uint dy);\n    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;\n    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;\n    function remove_liquidity(uint _amount, uint[3] calldata amounts) external;\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;\n    function calc_token_amount(uint[3] calldata amounts, bool deposit) external view returns (uint);\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);\n}\n"
    },
    "contracts/v3/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface ISwap {\n    function swapExactTokensForTokens(uint256, uint256, address[] calldata, address, uint256) external;\n    function getAmountsOut(uint256, address[] calldata) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/v3/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\nimport \"./ISwap.sol\";\n\ninterface IStrategy {\n    function balanceOf() external view returns (uint256);\n    function balanceOfPool() external view returns (uint256);\n    function balanceOfWant() external view returns (uint256);\n    function deposit() external;\n    function harvest(uint256, uint256) external;\n    function manager() external view returns (IManager);\n    function name() external view returns (string memory);\n    function router() external view returns (ISwap);\n    function skim() external;\n    function want() external view returns (address);\n    function weth() external view returns (address);\n    function withdraw(address) external;\n    function withdraw(uint256) external;\n    function withdrawAll() external;\n}\n"
    },
    "contracts/v3/strategies/MIMConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '../interfaces/IConvexVault.sol';\nimport '../interfaces/IStableSwap2Pool.sol';\nimport './BaseStrategy.sol';\n\ncontract MIMConvexStrategy is BaseStrategy {\n    // used for Crv -> weth -> [mim/3crv] -> mimCrv route\n    address public immutable crv;\n    address public immutable cvx;\n\n    address public immutable mim;\n    address public immutable crv3;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    address public immutable mimCvxDepositLP;\n    IConvexRewards public immutable crvRewards;\n    IStableSwap2Pool public immutable stableSwap2Pool;\n\n    /**\n     * @param _name The strategy name\n     * @param _want The desired token of the strategy\n     * @param _crv The address of CRV\n     * @param _cvx The address of CVX\n     * @param _weth The address of WETH\n     * @param _mim The address of MIM\n     * @param _crv3 The address of 3CRV\n     * @param _pid The pool id of convex\n     * @param _convexVault The address of the convex vault\n     * @param _stableSwap2Pool The address of the stable swap pool\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _router The address of the router for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _want,\n        address _crv,\n        address _cvx,\n        address _weth,\n        address _mim,\n        address _crv3,\n        uint256 _pid,\n        IConvexVault _convexVault,\n        IStableSwap2Pool _stableSwap2Pool,\n        address _controller,\n        address _manager,\n        address _router\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _router) {\n        require(address(_crv) != address(0), '!_crv');\n        require(address(_cvx) != address(0), '!_cvx');\n        require(address(_mim) != address(0), '!_mim');\n        require(address(_crv3) != address(0), '!_crv3');\n        require(address(_convexVault) != address(0), '!_convexVault');\n        require(address(_stableSwap2Pool) != address(0), '!_stableSwap2Pool');\n\n        (, address _token, , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = _crv;\n        cvx = _cvx;\n        mim = _mim;\n        crv3 = _crv3;\n        pid = _pid;\n        convexVault = _convexVault;\n        mimCvxDepositLP = _token;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwap2Pool = _stableSwap2Pool;\n        // Required to overcome \"Stack Too Deep\" error\n        _setApprovals(\n            _want,\n            _crv,\n            _cvx,\n            _mim,\n            _crv3,\n            address(_convexVault),\n            address(_stableSwap2Pool)\n        );\n    }\n\n    function _setApprovals(\n        address _want,\n        address _crv,\n        address _cvx,\n        address _mim,\n        address _crv3,\n        address _convexVault,\n        address _stableSwap2Pool\n    ) internal {\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        IERC20(_crv).safeApprove(address(router), type(uint256).max);\n        IERC20(_cvx).safeApprove(address(router), type(uint256).max);\n        IERC20(_mim).safeApprove(address(_stableSwap2Pool), type(uint256).max);\n        IERC20(_crv3).safeApprove(address(_stableSwap2Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap2Pool), type(uint256).max);\n    }\n\n    function _deposit() internal override {\n        if (balanceOfWant() > 0) {\n            convexVault.depositAll(pid, true);\n        }\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity() internal {\n        uint256[2] memory amounts;\n        amounts[0] = IERC20(mim).balanceOf(address(this));\n        amounts[1] = IERC20(crv3).balanceOf(address(this));\n        stableSwap2Pool.add_liquidity(amounts, 1);\n    }\n\n    function getMostPremium() public view returns (address, uint256) {\n        // both MIM and 3CRV have 18 decimals\n        if (stableSwap2Pool.balances(0) > stableSwap2Pool.balances(1)) {\n            return (crv3, 1);\n        }\n\n        return (mim, 0); // If they're somehow equal, we just want MIM\n    }\n\n    function _harvest(uint256 _estimatedWETH, uint256 _estimatedYAXIS) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokens(cvx, crv, _cvxBalance, 1);\n        }\n\n        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);\n\n        if (_remainingWeth > 0) {\n            (address _token, ) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _token, _remainingWeth, 1);\n            _addLiquidity();\n            _deposit();\n        }\n    }\n\n    function _withdrawAll() internal override {\n        convexVault.withdrawAll(pid);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        convexVault.withdraw(pid, _amount);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(mimCvxDepositLP).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/v3/interfaces/IConvexVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IConvexVault {\n    function poolInfo(uint256 pid) external view returns (address lptoken,\n                                                          address token,\n                                                          address gauge,\n                                                          address crvRewards,\n                                                          address stash,\n                                                          bool shutdown);\n\n    function deposit(uint256 pid, uint256 amount, bool stake) external returns(bool);\n    function depositAll(uint256 pid, bool stake) external returns(bool);\n    function withdraw(uint256 pid, uint256 amount) external returns(bool);\n    function withdrawAll(uint256 pid) external returns(bool);\n}\n\ninterface IConvexRewards {\n    function getReward(address _account, bool _claimExtras) external returns(bool);\n}\n"
    },
    "contracts/v3/interfaces/IStableSwap2Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IStableSwap2Pool {\n    function get_virtual_price() external view returns (uint256);\n\n    function balances(uint256) external view returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256 dy);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[2] calldata amounts) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n\n    function calc_token_amount(uint256[2] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/v3/strategies/GeneralConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IConvexVault.sol';\nimport '../interfaces/ExtendedIERC20.sol';\nimport '../interfaces/IStableSwapPool.sol';\nimport '../interfaces/IStableSwap2Pool.sol';\nimport './BaseStrategy.sol';\n\ncontract GeneralConvexStrategy is BaseStrategy {\n    using SafeMath for uint8;\n\n    address public immutable crv;\n    address public immutable cvx;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    address public immutable cvxDepositLP;\n    IConvexRewards public immutable crvRewards;\n    address public immutable stableSwapPool;\n\n    address[] public tokens;\n    uint8[] public decimalMultiples;\n\n    /**\n     * @param _name The strategy name\n     * @param _want The desired token of the strategy\n     * @param _crv The address of CRV\n     * @param _cvx The address of CVX\n     * @param _weth The address of WETH\n     * @param _pid The pool id of convex\n     * @param _coinCount The number of coins in the pool\n     * @param _convexVault The address of the convex vault\n     * @param _stableSwapPool The address of the stable swap pool\n     * @param _controller The address of the controller\n     * @param _manager The address of the manager\n     * @param _router The address of the router for swapping tokens\n     */\n    constructor(\n        string memory _name,\n        address _want,\n        address _crv,\n        address _cvx,\n        address _weth,\n        uint256 _pid,\n        uint256 _coinCount,\n        IConvexVault _convexVault,\n        address _stableSwapPool,\n        address _controller,\n        address _manager,\n        address _router\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _router) {\n        require(_coinCount == 2 || _coinCount == 3, '_coinCount should be 2 or 3');\n        require(address(_crv) != address(0), '!_crv');\n        require(address(_cvx) != address(0), '!_cvx');\n        require(address(_convexVault) != address(0), '!_convexVault');\n        require(address(_stableSwapPool) != address(0), '!_stableSwapPool');\n\n        (, address _token, , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = _crv;\n        cvx = _cvx;\n        pid = _pid;\n        convexVault = _convexVault;\n        cvxDepositLP = _token;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwapPool = _stableSwapPool;\n\n        for (uint256 i = 0; i < _coinCount; i++) {\n            tokens.push(IStableSwapPool(_stableSwapPool).coins(i));\n            decimalMultiples.push(18 - ExtendedIERC20(tokens[i]).decimals());\n            IERC20(tokens[i]).safeApprove(_stableSwapPool, type(uint256).max);\n        }\n\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        IERC20(_crv).safeApprove(address(_router), type(uint256).max);\n        IERC20(_cvx).safeApprove(address(_router), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwapPool), type(uint256).max);\n    }\n\n    function _deposit() internal override {\n        convexVault.depositAll(pid, true);\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity() internal {\n        if (tokens.length == 2) {\n            uint256[2] memory amounts;\n            amounts[0] = IERC20(tokens[0]).balanceOf(address(this));\n            amounts[1] = IERC20(tokens[1]).balanceOf(address(this));\n            IStableSwap2Pool(stableSwapPool).add_liquidity(amounts, 1);\n            return;\n        }\n\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(tokens[0]).balanceOf(address(this));\n        amounts[1] = IERC20(tokens[1]).balanceOf(address(this));\n        amounts[2] = IERC20(tokens[2]).balanceOf(address(this));\n        IStableSwap3Pool(stableSwapPool).add_liquidity(amounts, 1);\n    }\n\n    function getMostPremium() public view returns (address, uint256) {\n        uint256 balance0 = IStableSwap3Pool(stableSwapPool).balances(0).mul(\n            10**(decimalMultiples[0])\n        );\n        uint256 balance1 = IStableSwap3Pool(stableSwapPool).balances(1).mul(\n            10**(decimalMultiples[1])\n        );\n\n        if (tokens.length == 2) {\n            if (balance0 > balance1) {\n                return (tokens[1], 1);\n            }\n\n            return (tokens[0], 0);\n        }\n\n        uint256 balance2 = IStableSwap3Pool(stableSwapPool).balances(2).mul(\n            10**(decimalMultiples[2])\n        );\n\n        if (balance0 < balance1 && balance0 < balance2) {\n            return (tokens[0], 0);\n        }\n\n        if (balance1 < balance0 && balance1 < balance2) {\n            return (tokens[1], 1);\n        }\n\n        if (balance2 < balance0 && balance2 < balance1) {\n            return (tokens[2], 2);\n        }\n\n        return (tokens[0], 0);\n    }\n\n    function _harvest(uint256 _estimatedWETH, uint256 _estimatedYAXIS) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokens(cvx, crv, _cvxBalance, 1);\n        }\n\n        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);\n\n        if (_remainingWeth > 0) {\n            (address _stableCoin, ) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth, 1);\n            _addLiquidity();\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdrawAll() internal override {\n        convexVault.withdrawAll(pid);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        convexVault.withdraw(pid, _amount);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(cvxDepositLP).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/v3/interfaces/IStableSwapPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IStableSwapPool {\n    function coins(uint256) external view returns (address);\n}\n"
    },
    "contracts/v3/strategies/ConvexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport '../interfaces/IConvexVault.sol';\nimport './BaseStrategy.sol';\n\ncontract ConvexStrategy is BaseStrategy {\n    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route\n    address public immutable crv;\n    address public immutable cvx;\n\n    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    uint256 public immutable pid;\n    IConvexVault public immutable convexVault;\n    address public immutable cvxDepositLP;\n    IConvexRewards public immutable crvRewards;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n\n    constructor(\n        string memory _name,\n        address _want,\n        address _crv,\n        address _cvx,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        uint256 _pid,\n        IConvexVault _convexVault,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _manager,\n        address _router\n    ) public BaseStrategy(_name, _controller, _manager, _want, _weth, _router) {\n        (, address _token, , address _crvRewards, , ) = _convexVault.poolInfo(_pid);\n        crv = _crv;\n        cvx = _cvx;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        pid = _pid;\n        convexVault = _convexVault;\n        cvxDepositLP = _token;\n        crvRewards = IConvexRewards(_crvRewards);\n        stableSwap3Pool = _stableSwap3Pool;\n        // Required to overcome \"Stack Too Deep\" error\n        _setApprovals(\n            _want,\n            _crv,\n            _cvx,\n            _dai,\n            _usdc,\n            _usdt,\n            address(_convexVault),\n            _router,\n            address(_stableSwap3Pool)\n        );\n    }\n\n    function _setApprovals(\n        address _want,\n        address _crv,\n        address _cvx,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        address _convexVault,\n        address _router,\n        address _stableSwap3Pool\n    ) internal {\n        IERC20(_want).safeApprove(address(_convexVault), type(uint256).max);\n        IERC20(_crv).safeApprove(address(_router), type(uint256).max);\n        IERC20(_cvx).safeApprove(address(_router), type(uint256).max);\n        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n    }\n\n    function _deposit() internal override {\n        convexVault.depositAll(pid, true);\n    }\n\n    function _claimReward() internal {\n        crvRewards.getReward(address(this), true);\n    }\n\n    function _addLiquidity() internal {\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, 1);\n    }\n\n    function getMostPremium() public view returns (address, uint256) {\n        uint256[] memory balances = new uint256[](3);\n        balances[0] = stableSwap3Pool.balances(0); // DAI\n        balances[1] = stableSwap3Pool.balances(1).mul(10**12); // USDC\n        balances[2] = stableSwap3Pool.balances(2).mul(10**12); // USDT\n\n        if (balances[0] < balances[1] && balances[0] < balances[2]) {\n            // DAI\n            return (dai, 0);\n        }\n\n        if (balances[1] < balances[0] && balances[1] < balances[2]) {\n            // USDC\n            return (usdc, 1);\n        }\n\n        if (balances[2] < balances[0] && balances[2] < balances[1]) {\n            // USDT\n            return (usdt, 2);\n        }\n\n        return (dai, 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest(uint256 _estimatedWETH, uint256 _estimatedYAXIS) internal override {\n        _claimReward();\n        uint256 _cvxBalance = IERC20(cvx).balanceOf(address(this));\n        if (_cvxBalance > 0) {\n            _swapTokens(cvx, crv, _cvxBalance, 1);\n        }\n\n        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);\n\n        if (_remainingWeth > 0) {\n            (address _stableCoin, ) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth, 1);\n            _addLiquidity();\n\n            if (balanceOfWant() > 0) {\n                _deposit();\n            }\n        }\n    }\n\n    function _withdrawAll() internal override {\n        convexVault.withdrawAll(pid);\n    }\n\n    function _withdraw(uint256 _amount) internal override {\n        convexVault.withdraw(pid, _amount);\n    }\n\n    function balanceOfPool() public view override returns (uint256) {\n        return IERC20(cvxDepositLP).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/v3/mock/MockConvexVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport '../../mock/MockERC20.sol';\nimport './MockConvexBaseRewardPool.sol';\n\ncontract MockConvexVault {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crv;\n    address public immutable cvx;\n\n    address public owner;\n    address public immutable staker;\n    address public immutable minter;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address crvRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n\n    constructor(\n        address _staker,\n        address _minter,\n        address _crv,\n        address _cvx\n    ) public {\n        staker = _staker;\n        owner = msg.sender;\n        minter = _minter;\n        crv = _crv;\n        cvx = _cvx;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    //create a new pool\n    function addPool(\n        address _lptoken,\n        address _gauge,\n        uint256 /*_stashVersion*/\n    ) external returns (bool) {\n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        MockERC20 token = new MockERC20(\n            string(abi.encodePacked(ERC20(_lptoken).name(), ' Convex Deposit')),\n            string(abi.encodePacked('cvx', ERC20(_lptoken).symbol())),\n            18\n        );\n\n        //create a reward contract for crv rewards\n        MockConvexBaseRewardPool newRewardPool = new MockConvexBaseRewardPool(\n            pid,\n            address(token),\n            crv,\n            address(this),\n            address(this)\n        );\n\n        // give some fake generated rewards to reward pool so user can claim\n        IERC20(cvx).safeTransferFrom(address(this), address(newRewardPool), 10000);\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: address(token),\n                gauge: _gauge,\n                crvRewards: address(newRewardPool),\n                stash: address(0),\n                shutdown: false\n            })\n        );\n        return true;\n    }\n\n    //deposit lp tokens and stake\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool /*_stake*/\n    ) public returns (bool) {\n        PoolInfo storage pool = poolInfo[_pid];\n        //send to proxy to stake\n        address lptoken = pool.lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, address(this), _amount);\n\n        address token = pool.token;\n\n        //add user balance directly\n        MockERC20(token).mint(msg.sender, _amount);\n\n        emit Deposited(msg.sender, _pid, _amount);\n        return true;\n    }\n\n    //deposit all lp tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns (bool) {\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid, balance, _stake);\n        return true;\n    }\n\n    //withdraw lp tokens\n    function _withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _from,\n        address _to\n    ) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        address lptoken = pool.lptoken;\n\n        //remove lp balance\n        address token = pool.token;\n        MockERC20(token).burnFrom(_from, _amount);\n\n        //return lp tokens\n        IERC20(lptoken).safeTransfer(_to, _amount);\n\n        emit Withdrawn(_to, _pid, _amount);\n    }\n\n    //withdraw lp tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {\n        _withdraw(_pid, _amount, msg.sender, msg.sender);\n        return true;\n    }\n\n    //withdraw all lp tokens\n    function withdrawAll(uint256 _pid) public returns (bool) {\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/mock/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ncontract MockERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    address private _owner;\n\n    uint internal _totalSupply;\n\n    mapping(address => uint)                   private _balance;\n    mapping(address => mapping(address => uint)) private _allowance;\n\n    modifier _onlyOwner_() {\n        require(msg.sender == _owner, \"ERR_NOT_OWNER\");\n        _;\n    }\n\n    event Approval(address indexed src, address indexed dst, uint amt);\n    event Transfer(address indexed src, address indexed dst, uint amt);\n\n    // Math\n    function add(uint a, uint b) internal pure returns (uint c) {\n        require((c = a + b) >= a);\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require((c = a - b) <= a);\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _owner = msg.sender;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function _move(address src, address dst, uint amt) internal {\n        require(_balance[src] >= amt, \"!bal\");\n        _balance[src] = sub(_balance[src], amt);\n        _balance[dst] = add(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint amt) internal {\n        _move(from, address(this), amt);\n    }\n\n    function _mint(address dst, uint amt) internal {\n        _balance[dst] = add(_balance[dst], amt);\n        _totalSupply = add(_totalSupply, amt);\n        emit Transfer(address(0), dst, amt);\n    }\n\n    function _burn(address dst, uint amt) internal {\n        _balance[dst] = sub(_balance[dst], amt);\n        _totalSupply = sub(_totalSupply, amt);\n        emit Transfer(dst, address(0), amt);\n    }\n\n    function allowance(address src, address dst) external view returns (uint) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) public view returns (uint) {\n        return _balance[whom];\n    }\n\n    function faucet(uint256 amt) public returns (bool) {\n        _mint(msg.sender, amt);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint amt) external returns (bool) {\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function mint(address dst, uint256 amt) public _onlyOwner_ returns (bool) {\n        _mint(dst, amt);\n        return true;\n    }\n\n    function burn(uint amt) public returns (bool) {\n        require(_balance[msg.sender] >= amt, \"!bal\");\n        _burn(msg.sender, amt);\n        return true;\n    }\n\n    function burnFrom(address src, uint amt) public _onlyOwner_ returns (bool) {\n        require(_balance[src] >= amt, \"!bal\");\n        _burn(src, amt);\n        return true;\n    }\n\n    function transfer(address dst, uint amt) external returns (bool) {\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint amt) external returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"!spender\");\n        _move(src, dst, amt);\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(- 1)) {\n            _allowance[src][msg.sender] = sub(_allowance[src][msg.sender], amt);\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n        return true;\n    }\n\n    function transferOwnership(address newOwner) external _onlyOwner_ {\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/v3/mock/MockConvexBaseRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\ncontract MockConvexBaseRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n\n    uint256 public pid;\n\n    constructor(\n        uint256 pid_,\n        address, /*stakingToken_*/\n        address rewardToken_,\n        address, /*operator_*/\n        address /*rewardManager_*/\n    ) public {\n        pid = pid_;\n        rewardToken = IERC20(rewardToken_);\n    }\n\n    function stakeFor(\n        address, /*_for*/\n        uint256 /*_amount*/\n    ) public pure returns (bool) {\n        return true;\n    }\n\n    function getReward(\n        address _account,\n        bool /*_claimExtras*/\n    ) public returns (bool) {\n        IERC20(rewardToken).safeTransferFrom(address(this), _account, 1000);\n        return true;\n    }\n}\n"
    },
    "contracts/v3/MinterWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract MinterWrapper is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 public immutable token;\n    address public minter;\n    uint256 public rate;\n\n    event Write();\n\n    constructor(\n        address _token\n    )\n        public\n        Ownable()\n    {\n        token = IERC20(_token);\n        rate = 1e12;\n    }\n\n    /**\n     * @notice Sets the address of the minter contract\n     * @dev can only be set once\n     * @param _minter The address of the minter\n     */\n    function setMinter(\n        address _minter\n    )\n        external\n        onlyOwner\n    {\n        require(minter == address(0), \"minter\");\n        require(_minter != address(0), \"!_minter\");\n        minter = _minter;\n    }\n\n    /**\n     * @notice Sets the emission rate\n     * @param _rate The rate of reward token emissions\n     */\n    function setRate(\n        uint256 _rate\n    )\n        external\n        onlyOwner\n    {\n        rate = _rate;\n    }\n\n    /**\n     * @notice Mints the given amount to the given account\n     * @dev Requires this contract to be funded with the reward token\n     * @param _account The address to receive the reward tokens\n     * @param _amount The amount of tokens to send the receiver\n     */\n    function mint(\n        address _account,\n        uint256 _amount\n    )\n        external\n        returns (bool)\n    {\n        require(msg.sender == minter, \"!minter\");\n        token.safeTransfer(_account, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Returns the current block timestamp\n     * @dev Emits Write event to prevent from being a view function\n     */\n    function future_epoch_time_write()\n        external\n        returns (uint256)\n    {\n        emit Write();\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Returns the amount of reward tokens on this contract\n     */\n    function available_supply()\n        public\n        view\n        returns (uint256)\n    {\n        return token.balanceOf(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/legacy/MetaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./IVaultManager.sol\";\nimport \"./IController.sol\";\nimport \"./IConverter.sol\";\nimport \"./IMetaVault.sol\";\n\n/**\n * @title MetaVault (yAxisMetaVault)\n * @notice The metavault is where users deposit and withdraw stablecoins\n * @dev This metavault will pay YAX incentive for depositors and stakers\n * It does not need minter key of YAX. Governance multisig will mint total\n * of 34000 YAX and send into the vault in the beginning\n */\ncontract MetaVault is ERC20, IMetaVault {\n    using Address for address;\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    IERC20[4] public inputTokens; // DAI, USDC, USDT, 3Crv\n\n    IERC20 public token3CRV;\n    IERC20 public tokenYAX;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    uint public earnLowerlimit = 5 ether; // minimum to invest is 5 3CRV\n    uint public totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar\n\n    address public governance;\n    address public controller;\n    uint public insurance;\n    IVaultManager public vaultManager;\n    IConverter public converter;\n\n    bool public acceptContractDepositor = false; // dont accept contract at beginning\n\n    struct UserInfo {\n        uint amount;\n        uint yaxRewardDebt;\n        uint accEarned;\n    }\n\n    uint public lastRewardBlock;\n    uint public accYaxPerShare;\n\n    uint public yaxPerBlock;\n\n    mapping(address => UserInfo) public userInfo;\n\n    address public treasuryWallet = 0x362Db1c17db4C79B51Fe6aD2d73165b1fe9BaB4a;\n\n    uint public constant BLOCKS_PER_WEEK = 46500;\n\n    // Block number when each epoch ends.\n    uint[5] public epochEndBlocks;\n\n    // Reward multipler for each of 5 epoches (epochIndex: reward multipler)\n    uint[6] public epochRewardMultiplers = [86000, 64000, 43000, 21000, 10000, 1];\n\n    /**\n     * @notice Emitted when a user deposits funds\n     */\n    event Deposit(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when a user withdraws funds\n     */\n    event Withdraw(address indexed user, uint amount);\n\n    /**\n     * @notice Emitted when YAX is paid to a user\n     */\n    event RewardPaid(address indexed user, uint reward);\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _tokenYAX The address of the YAX token\n     * @param _yaxPerBlock The amount of YAX rewarded per block\n     * @param _startBlock The starting block for rewards\n     */\n    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV, IERC20 _tokenYAX,\n        uint _yaxPerBlock, uint _startBlock) public ERC20(\"yAxis.io:MetaVault:3CRV\", \"MVLT\") {\n        inputTokens[0] = _tokenDAI;\n        inputTokens[1] = _tokenUSDC;\n        inputTokens[2] = _tokenUSDT;\n        inputTokens[3] = _token3CRV;\n        token3CRV = _token3CRV;\n        tokenYAX = _tokenYAX;\n        yaxPerBlock = _yaxPerBlock; // supposed to be 0.000001 YAX (1000000000000 = 1e12 wei)\n        lastRewardBlock = (_startBlock > block.number) ? _startBlock : block.number; // supposed to be 11,163,000 (Sat Oct 31 2020 06:30:00 GMT+0)\n        epochEndBlocks[0] = lastRewardBlock + BLOCKS_PER_WEEK * 2; // weeks 1-2\n        epochEndBlocks[1] = epochEndBlocks[0] + BLOCKS_PER_WEEK * 2; // weeks 3-4\n        epochEndBlocks[2] = epochEndBlocks[1] + BLOCKS_PER_WEEK * 4; // month 2\n        epochEndBlocks[3] = epochEndBlocks[2] + BLOCKS_PER_WEEK * 8; // month 3-4\n        epochEndBlocks[4] = epochEndBlocks[3] + BLOCKS_PER_WEEK * 8; // month 5-6\n        governance = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by a contract and we are not allowing.\n     */\n    modifier checkContract() {\n        if (!acceptContractDepositor) {\n            require(!address(msg.sender).isContract() && msg.sender == tx.origin, \"Sorry we do not accept contract!\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Returns the current token3CRV balance of the vault and controller, minus insurance\n     * @dev Ignore insurance fund for balance calculations\n     */\n    function balance() public override view returns (uint) {\n        uint bal = token3CRV.balanceOf(address(this));\n        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(token3CRV)));\n        return bal.sub(insurance);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for min\n     * @param _min The new min value\n     */\n    function setMin(uint _min) external {\n        require(msg.sender == governance, \"!governance\");\n        min = _min;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the governance address\n     * @param _governance The new governance value\n     */\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the controller address\n     * @param _controller The new controller value\n     */\n    function setController(address _controller) public override {\n        require(msg.sender == governance, \"!governance\");\n        controller = _controller;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the converter address\n     * @param _converter The new converter value\n     * @dev Requires that the return address of token() from the converter is the\n     * same as token3CRV\n     */\n    function setConverter(IConverter _converter) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_converter.token() == address(token3CRV), \"!token3CRV\");\n        converter = _converter;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the vaultManager address\n     * @param _vaultManager The new vaultManager value\n     */\n    function setVaultManager(IVaultManager _vaultManager) public {\n        require(msg.sender == governance, \"!governance\");\n        vaultManager = _vaultManager;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the earnLowerlimit\n     * @dev earnLowerlimit determines the minimum balance of this contract for earn\n     * to be called\n     * @param _earnLowerlimit The new earnLowerlimit value\n     */\n    function setEarnLowerlimit(uint _earnLowerlimit) public {\n        require(msg.sender == governance, \"!governance\");\n        earnLowerlimit = _earnLowerlimit;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(uint _totalDepositCap) public {\n        require(msg.sender == governance, \"!governance\");\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for acceptContractDepositor\n     * @dev acceptContractDepositor allows the metavault to accept deposits from\n     * smart contract addresses\n     * @param _acceptContractDepositor The new acceptContractDepositor value\n     */\n    function setAcceptContractDepositor(bool _acceptContractDepositor) public {\n        require(msg.sender == governance, \"!governance\");\n        acceptContractDepositor = _acceptContractDepositor;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for yaxPerBlock\n     * @dev Makes a call to updateReward()\n     * @param _yaxPerBlock The new yaxPerBlock value\n     */\n    function setYaxPerBlock(uint _yaxPerBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        updateReward();\n        yaxPerBlock = _yaxPerBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochEndBlocks at the given index\n     * @dev Throws if _index >= 5\n     * @dev Throws if _epochEndBlock > the current block.number\n     * @dev Throws if the stored block.number at the given index is > the current block.number\n     * @param _index The index to set of epochEndBlocks\n     * @param _epochEndBlock The new epochEndBlocks value at the index\n     */\n    function setEpochEndBlock(uint8 _index, uint256 _epochEndBlock) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index < 5, \"_index out of range\");\n        require(_epochEndBlock > block.number, \"Too late to update\");\n        require(epochEndBlocks[_index] > block.number, \"Too late to update\");\n        epochEndBlocks[_index] = _epochEndBlock;\n    }\n\n    /**\n     * @notice Called by Governance to set the value for epochRewardMultiplers at the given index\n     * @dev Throws if _index < 1 or > 5\n     * @dev Throws if the stored block.number at the previous index is > the current block.number\n     * @param _index The index to set of epochRewardMultiplers\n     * @param _epochRewardMultipler The new epochRewardMultiplers value at the index\n     */\n    function setEpochRewardMultipler(uint8 _index, uint256 _epochRewardMultipler) public {\n        require(msg.sender == governance, \"!governance\");\n        require(_index > 0 && _index < 6, \"Index out of range\");\n        require(epochEndBlocks[_index - 1] > block.number, \"Too late to update\");\n        epochRewardMultiplers[_index] = _epochRewardMultipler;\n    }\n\n    /**\n     * @notice Return reward multiplier over the given _from to _to block.\n     * @param _from The from block\n     * @param _to The to block\n     */\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        // start at the end of the epochs\n        for (uint8 epochId = 5; epochId >= 1; --epochId) {\n            // if _to (the current block number if called within this contract) is after the previous epoch ends\n            if (_to >= epochEndBlocks[epochId - 1]) {\n                // if the last reward block is after the previous epoch: return the number of blocks multiplied by this epochs multiplier\n                if (_from >= epochEndBlocks[epochId - 1]) return _to.sub(_from).mul(epochRewardMultiplers[epochId]);\n                // get the multiplier amount for the remaining reward of the current epoch\n                uint256 multiplier = _to.sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]);\n                // if epoch is 1: return the remaining current epoch reward with the first epoch reward\n                if (epochId == 1) return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n                // for all epochs in between the first and current epoch\n                for (epochId = epochId - 1; epochId >= 1; --epochId) {\n                    // if the last reward block is after the previous epoch: return the current remaining reward with the previous epoch\n                    if (_from >= epochEndBlocks[epochId - 1]) return multiplier.add(epochEndBlocks[epochId].sub(_from).mul(epochRewardMultiplers[epochId]));\n                    // accumulate the multipler with the reward from the epoch\n                    multiplier = multiplier.add(epochEndBlocks[epochId].sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]));\n                }\n                // return the accumulated multiplier with the reward from the first epoch\n                return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));\n            }\n        }\n        // return the reward amount between _from and _to in the first epoch\n        return _to.sub(_from).mul(epochRewardMultiplers[0]);\n    }\n\n    /**\n     * @notice Called by Governance to set the value for the treasuryWallet\n     * @param _treasuryWallet The new treasuryWallet value\n     */\n    function setTreasuryWallet(address _treasuryWallet) public {\n        require(msg.sender == governance, \"!governance\");\n        treasuryWallet = _treasuryWallet;\n    }\n\n    /**\n     * @notice Called by Governance or the controller to claim the amount stored in the insurance fund\n     * @dev If called by the controller, insurance will auto compound the vault, increasing getPricePerFullShare\n     */\n    function claimInsurance() external override {\n        // if claim by controller for auto-compounding (current insurance will stay to increase sharePrice)\n        // otherwise send the fund to treasuryWallet\n        if (msg.sender != controller) {\n            // claim by governance for insurance\n            require(msg.sender == governance, \"!governance\");\n            token3CRV.safeTransfer(treasuryWallet, insurance);\n        }\n        insurance = 0;\n    }\n\n    /**\n     * @notice Get the address of the 3CRV token\n     */\n    function token() public override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Get the amount that the metavault allows to be borrowed\n     * @dev min and max are used to keep small withdrawals cheap\n     */\n    function available() public override view returns (uint) {\n        return token3CRV.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    /**\n     * @notice If the controller is set, returns the withdrawFee of the 3CRV token for the given _amount\n     * @param _amount The amount being queried to withdraw\n     */\n    function withdrawFee(uint _amount) public override view returns (uint) {\n        return (controller == address(0)) ? 0 : IController(controller).withdrawFee(address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn() public override {\n        if (controller != address(0)) {\n            IController _contrl = IController(controller);\n            if (_contrl.investEnabled()) {\n                uint _bal = available();\n                token3CRV.safeTransfer(controller, _bal);\n                _contrl.earn(address(token3CRV), _bal);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV given for the amounts deposited\n     * @param amounts The stablecoin amounts being deposited\n     */\n    function calc_token_amount_deposit(uint[3] calldata amounts) external override view returns (uint) {\n        return converter.calc_token_amount(amounts, true);\n    }\n\n    /**\n     * @notice Returns the amount given in the desired token for the given shares\n     * @param _shares The amount of shares to withdraw\n     * @param _output The desired token to withdraw\n     */\n    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {\n        uint _withdrawFee = withdrawFee(_shares);\n        if (_withdrawFee > 0) {\n            _shares = _shares.mul(10000 - _withdrawFee).div(10000);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        if (_output == address(token3CRV)) {\n            return r;\n        }\n        return converter.calc_token_amount_withdraw(r, _output);\n    }\n\n    /**\n     * @notice Returns the amount of 3CRV that would be given for the amount of input tokens\n     * @param _input The stablecoin to convert to 3CRV\n     * @param _amount The amount of stablecoin to convert\n     */\n    function convert_rate(address _input, uint _amount) external override view returns (uint) {\n        return converter.convert_rate(_input, address(token3CRV), _amount);\n    }\n\n    /**\n     * @notice Deposit a single stablecoin to the metavault\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amount The amount of the stablecoin to deposit\n     * @param _input The address of the stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external override checkContract {\n        require(_amount > 0, \"!_amount\");\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        if (_input == address(token3CRV)) {\n            token3CRV.safeTransferFrom(msg.sender, address(this), _amount);\n        } else if (converter.convert_rate(_input, address(token3CRV), _amount) > 0) {\n            IERC20(_input).safeTransferFrom(msg.sender, address(converter), _amount);\n            converter.convert(_input, address(token3CRV), _amount);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_amount >= _min_mint_amount, \"slippage\");\n        if (_amount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _amount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _amount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Deposits multiple stablecoins simultaneously to the metavault\n     * @dev 0: DAI, 1: USDC, 2: USDT, 3: 3CRV\n     * @dev Users must approve the metavault to spend their stablecoin\n     * @param _amounts The amounts of each stablecoin being deposited\n     * @param _min_mint_amount The expected amount of shares to receive\n     * @param _isStake Stakes shares or not\n     */\n    function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {\n        uint _pool = balance();\n        uint _before = token3CRV.balanceOf(address(this));\n        bool hasStables = false;\n        for (uint8 i = 0; i < 4; i++) {\n            uint _inputAmount = _amounts[i];\n            if (_inputAmount > 0) {\n                if (i == 3) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(this), _inputAmount);\n                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {\n                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);\n                    hasStables = true;\n                }\n            }\n        }\n        if (hasStables) {\n            uint[3] memory _stablesAmounts;\n            _stablesAmounts[0] = _amounts[0];\n            _stablesAmounts[1] = _amounts[1];\n            _stablesAmounts[2] = _amounts[2];\n            converter.convert_stables(_stablesAmounts);\n        }\n        uint _after = token3CRV.balanceOf(address(this));\n        require(totalDepositCap == 0 || _after <= totalDepositCap, \">totalDepositCap\");\n        uint _totalDepositAmount = _after.sub(_before); // Additional check for deflationary tokens\n        require(_totalDepositAmount >= _min_mint_amount, \"slippage\");\n        if (_totalDepositAmount > 0) {\n            if (!_isStake) {\n                _deposit(msg.sender, _pool, _totalDepositAmount);\n            } else {\n                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);\n                _stakeShares(_shares);\n            }\n        }\n    }\n\n    /**\n     * @notice Stakes metavault shares\n     * @param _shares The amount of shares to stake\n     */\n    function stakeShares(uint _shares) external {\n        uint _before = balanceOf(address(this));\n        IERC20(address(this)).transferFrom(msg.sender, address(this), _shares);\n        uint _after = balanceOf(address(this));\n        _shares = _after.sub(_before);\n        // Additional check for deflationary tokens\n        _stakeShares(_shares);\n    }\n\n    function _deposit(address _mintTo, uint _pool, uint _amount) internal returns (uint _shares) {\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _insuranceFee = vaultManager.insuranceFee();\n            if (_insuranceFee > 0) {\n                uint _insurance = _amount.mul(_insuranceFee).div(10000);\n                _amount = _amount.sub(_insurance);\n                insurance = insurance.add(_insurance);\n            }\n        }\n\n        if (totalSupply() == 0) {\n            _shares = _amount;\n        } else {\n            _shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        if (_shares > 0) {\n            if (token3CRV.balanceOf(address(this)) > earnLowerlimit) {\n                earn();\n            }\n            _mint(_mintTo, _shares);\n        }\n    }\n\n    function _stakeShares(uint _shares) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        updateReward();\n        _getReward();\n        user.amount = user.amount.add(_shares);\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Deposit(msg.sender, _shares);\n    }\n\n    /**\n     * @notice Returns the pending YAXs for a given account\n     * @param _account The address to query\n     */\n    function pendingYax(address _account) public view returns (uint _pending) {\n        UserInfo storage user = userInfo[_account];\n        uint _accYaxPerShare = accYaxPerShare;\n        uint lpSupply = balanceOf(address(this));\n        if (block.number > lastRewardBlock && lpSupply != 0) {\n            uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n            _accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        }\n        _pending = user.amount.mul(_accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n    }\n\n    /**\n     * @notice Sets the lastRewardBlock and accYaxPerShare\n     */\n    function updateReward() public {\n        if (block.number <= lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = balanceOf(address(this));\n        if (lpSupply == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n        uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);\n        accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));\n        lastRewardBlock = block.number;\n    }\n\n    function _getReward() internal {\n        UserInfo storage user = userInfo[msg.sender];\n        uint _pendingYax = user.amount.mul(accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);\n        if (_pendingYax > 0) {\n            user.accEarned = user.accEarned.add(_pendingYax);\n            safeYaxTransfer(msg.sender, _pendingYax);\n            emit RewardPaid(msg.sender, _pendingYax);\n        }\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired stablecoin to receive\n     */\n    function withdrawAll(address _output) external {\n        unstake(userInfo[msg.sender].amount);\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\n     * @param reserve The address of the token to swap to 3CRV\n     * @param amount The amount to swap\n     */\n    function harvest(address reserve, uint amount) external override {\n        require(msg.sender == controller, \"!controller\");\n        require(reserve != address(token3CRV), \"token3CRV\");\n        IERC20(reserve).safeTransfer(controller, amount);\n    }\n\n    /**\n     * @notice Unstakes the given shares from the metavault\n     * @dev call unstake(0) to only receive the reward\n     * @param _amount The amount to unstake\n     */\n    function unstake(uint _amount) public {\n        updateReward();\n        _getReward();\n        UserInfo storage user = userInfo[msg.sender];\n        if (_amount > 0) {\n            require(user.amount >= _amount, \"stakedBal < _amount\");\n            user.amount = user.amount.sub(_amount);\n            IERC20(address(this)).transfer(msg.sender, _amount);\n        }\n        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output stablecoin\n     * @dev No rebalance implementation for lower fees and faster swaps\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the stablecoin to receive\n     */\n    function withdraw(uint _shares, address _output) public override {\n        uint _userBal = balanceOf(msg.sender);\n        if (_shares > _userBal) {\n            uint _need = _shares.sub(_userBal);\n            require(_need <= userInfo[msg.sender].amount, \"_userBal+staked < _shares\");\n            unstake(_need);\n        }\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        if (address(vaultManager) != address(0)) {\n            // expected 0.1% of withdrawal go back to vault (for auto-compounding) to protect withdrawals\n            // it is updated by governance (community vote)\n            uint _withdrawalProtectionFee = vaultManager.withdrawalProtectionFee();\n            if (_withdrawalProtectionFee > 0) {\n                uint _withdrawalProtection = r.mul(_withdrawalProtectionFee).div(10000);\n                r = r.sub(_withdrawalProtection);\n            }\n        }\n\n        // Check balance\n        uint b = token3CRV.balanceOf(address(this));\n        if (b < r) {\n            uint _toWithdraw = r.sub(b);\n            if (controller != address(0)) {\n                IController(controller).withdraw(address(token3CRV), _toWithdraw);\n            }\n            uint _after = token3CRV.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _toWithdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        if (_output == address(token3CRV)) {\n            token3CRV.safeTransfer(msg.sender, r);\n        } else {\n            require(converter.convert_rate(address(token3CRV), _output, r) > 0, \"rate=0\");\n            token3CRV.safeTransfer(address(converter), r);\n            uint _outputAmount = converter.convert(address(token3CRV), _output, r);\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n        }\n    }\n\n    /**\n     * @notice Returns the address of the 3CRV token\n     */\n    function want() external override view returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Returns the rate of earnings of a single share\n     */\n    function getPricePerFullShare() external override view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @notice Transfers YAX from the metavault to a given address\n     * @dev Ensures the metavault has enough balance to transfer\n     * @param _to The address to transfer to\n     * @param _amount The amount to transfer\n     */\n    function safeYaxTransfer(address _to, uint _amount) internal {\n        uint _tokenBal = tokenYAX.balanceOf(address(this));\n        tokenYAX.safeTransfer(_to, (_tokenBal < _amount) ? _tokenBal : _amount);\n    }\n\n    /**\n     * @notice Converts non-3CRV stablecoins held in the metavault to 3CRV\n     * @param _token The address to convert\n     */\n    function earnExtra(address _token) public {\n        require(msg.sender == governance, \"!governance\");\n        require(address(_token) != address(token3CRV), \"3crv\");\n        require(address(_token) != address(this), \"mlvt\");\n        uint _amount = IERC20(_token).balanceOf(address(this));\n        require(converter.convert_rate(_token, address(token3CRV), _amount) > 0, \"rate=0\");\n        IERC20(_token).safeTransfer(address(converter), _amount);\n        converter.convert(_token, address(token3CRV), _amount);\n    }\n}\n"
    },
    "contracts/legacy/IVaultManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IVaultManager {\n    function controllers(address) external view returns (bool);\n    function getHarvestFeeInfo() external view returns (address, address, uint256, address, uint256, address, uint256);\n    function governance() external view returns (address);\n    function harvester() external view returns (address);\n    function insuranceFee() external view returns (uint256);\n    function insurancePool() external view returns (address);\n    function insurancePoolFee() external view returns (uint256);\n    function stakingPool() external view returns (address);\n    function stakingPoolShareFee() external view returns (uint256);\n    function strategist() external view returns (address);\n    function treasury() external view returns (address);\n    function treasuryBalance() external view returns (uint256);\n    function treasuryFee() external view returns (uint256);\n    function vaults(address) external view returns (bool);\n    function withdrawalProtectionFee() external view returns (uint256);\n    function yax() external view returns (address);\n}\n"
    },
    "contracts/legacy/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IController {\n    function balanceOf(address) external view returns (uint256);\n    function earn(address, uint256) external;\n    function investEnabled() external view returns (bool);\n    function harvestStrategy(address) external;\n    function strategyTokens(address) external returns (address);\n    function vaults(address) external view returns (address);\n    function want(address) external view returns (address);\n    function withdraw(address, uint256) external;\n    function withdrawFee(address, uint256) external view returns (uint256);\n}\n"
    },
    "contracts/legacy/IConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IConverter {\n    function token() external view returns (address _share);\n    function convert(\n        address _input,\n        address _output,\n        uint _inputAmount\n    ) external returns (uint _outputAmount);\n    function convert_rate(\n        address _input,\n        address _output,\n        uint _inputAmount\n    ) external view returns (uint _outputAmount);\n    function convert_stables(\n        uint[3] calldata amounts\n    ) external returns (uint _shareAmount); // 0: DAI, 1: USDC, 2: USDT\n    function calc_token_amount(\n        uint[3] calldata amounts,\n        bool deposit\n    ) external view returns (uint _shareAmount);\n    function calc_token_amount_withdraw(\n        uint _shares,\n        address _output\n    ) external view returns (uint _outputAmount);\n    function setStrategy(address _strategy, bool _status) external;\n}\n"
    },
    "contracts/legacy/IMetaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface IMetaVault {\n    function balance() external view returns (uint);\n    function setController(address _controller) external;\n    function claimInsurance() external;\n    function token() external view returns (address);\n    function available() external view returns (uint);\n    function withdrawFee(uint _amount) external view returns (uint);\n    function earn() external;\n    function calc_token_amount_deposit(uint[3] calldata amounts) external view returns (uint);\n    function calc_token_amount_withdraw(uint _shares, address _output) external view returns (uint);\n    function convert_rate(address _input, uint _amount) external view returns (uint);\n    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external;\n    function harvest(address reserve, uint amount) external;\n    function withdraw(uint _shares, address _output) external;\n    function want() external view returns (address);\n    function getPricePerFullShare() external view returns (uint);\n}\n"
    },
    "contracts/legacy/MetaVaultNonConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./IConverter.sol\";\nimport \"./IVaultManager.sol\";\n\n/**\n * @title MetaVaultNonConverter (StableSwap3PoolConverter)\n * @notice The StableSwap3PoolConverter is used to convert funds on Curve's 3Pool.\n * This is a safe version that does not allow the vault to be used for arbitrage.\n */\ncontract MetaVaultNonConverter is IConverter {\n    using SafeERC20 for IERC20;\n\n    IVaultManager public immutable vaultManager;\n    IERC20 public immutable token3CRV; // 3Crv\n\n    /**\n     * @param _token3CRV The address of the 3CRV token\n     * @param _vaultManager The address of the Vault Manager\n     */\n    constructor(\n        IERC20 _token3CRV,\n        IVaultManager _vaultManager\n    ) public {\n        token3CRV = _token3CRV;\n        vaultManager = _vaultManager;\n    }\n\n    /**\n     * @notice Called by Governance to enable or disable a strategy to use the converter\n     */\n    function setStrategy(address, bool) external override onlyGovernance {\n        return;\n    }\n\n    /**\n     * @notice Called by Governance to approve a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyGovernance {\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Returns the address of the 3CRV token\n     */\n    function token() external view override returns (address) {\n        return address(token3CRV);\n    }\n\n    /**\n     * @notice Converts the amount of input tokens to output tokens\n     */\n    function convert(\n        address,\n        address,\n        uint256\n    ) external override returns (uint256) {\n        revert(\"Only 3CRV allowed\");\n    }\n\n    /**\n     * @notice Checks the amount of input tokens to output tokens\n     */\n    function convert_rate(\n        address,\n        address,\n        uint256\n    ) external override view returns (uint256) {\n        revert(\"Only 3CRV allowed\");\n    }\n\n    /**\n     * @notice Converts stables of the 3Pool to 3CRV\n     */\n    function convert_stables(\n        uint256[3] calldata\n    ) external override returns (uint256) {\n        revert(\"Only 3CRV allowed\");\n    }\n\n    /**\n     * @notice Checks the amount of 3CRV given for the amounts\n     */\n    function calc_token_amount(\n        uint256[3] calldata,\n        bool\n    ) external override view returns (uint256) {\n        revert(\"Only 3CRV allowed\");\n    }\n\n    /**\n     * @notice Checks the amount of an output token given for 3CRV\n     */\n    function calc_token_amount_withdraw(\n        uint256,\n        address\n    ) external override view returns (uint256) {\n        revert(\"Only 3CRV allowed\");\n    }\n\n    /**\n     * @notice Allows Governance to withdraw tokens from the converter\n     * @dev This contract should never have any tokens in it at the end of a transaction\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to receive the tokens\n     */\n    function governanceRecoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    ) external onlyGovernance {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @dev Throws if not called by a controller or governance\n     */\n    modifier onlyGovernance() {\n        require(vaultManager.controllers(msg.sender)\n            || msg.sender == vaultManager.governance(), \"!governance\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/converters/StablesConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/IManager.sol\";\nimport \"../interfaces/ICurve3Pool.sol\";\n\n/**\n * @title StablesConverter\n */\ncontract StablesConverter is IConverter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IManager public immutable override manager;\n    ICurve3Pool public immutable stableSwap3Pool;\n    IERC20 public immutable token3CRV; // 3Crv\n\n    IERC20[3] public tokens; // DAI, USDC, USDT\n\n    mapping(address => int128) internal indices;\n\n    /**\n     * @param _tokenDAI The address of the DAI token\n     * @param _tokenUSDC The address of the USDC token\n     * @param _tokenUSDT The address of the USDT token\n     * @param _token3CRV The address of the 3CRV token\n     * @param _stableSwap3Pool The address of 3Pool\n     * @param _manager The address of the Vault Manager\n     */\n    constructor(\n        IERC20 _tokenDAI,\n        IERC20 _tokenUSDC,\n        IERC20 _tokenUSDT,\n        IERC20 _token3CRV,\n        ICurve3Pool _stableSwap3Pool,\n        IManager _manager\n    ) public {\n        tokens[0] = _tokenDAI;\n        tokens[1] = _tokenUSDC;\n        tokens[2] = _tokenUSDT;\n        indices[address(_tokenDAI)] = 0;\n        indices[address(_tokenUSDC)] = 1;\n        indices[address(_tokenUSDT)] = 2;\n        token3CRV = _token3CRV;\n        stableSwap3Pool = _stableSwap3Pool;\n        tokens[0].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        tokens[1].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        tokens[2].safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        _token3CRV.safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        manager = _manager;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Called by the strategist to approve a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    )\n        external\n        onlyStrategist\n    {\n        _token.safeApprove(_spender, 0);\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Allows the strategist to withdraw tokens from the converter\n     * @dev This contract should never have any tokens in it at the end of a transaction\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to receive the tokens\n     */\n    function recoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    )\n        external\n        onlyStrategist\n    {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * AUTHORIZED-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Converts the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     * @param _estimatedOutput The estimated output tokens after converting\n     */\n    function convert(\n        address _input,\n        address _output,\n        uint256 _inputAmount,\n        uint256 _estimatedOutput\n    )\n        external\n        override\n        onlyAuthorized\n        returns (uint256 _outputAmount)\n    {\n        if (_output == address(token3CRV)) { // convert to 3CRV\n            uint256[3] memory amounts;\n            for (uint8 i = 0; i < 3; i++) {\n                if (_input == address(tokens[i])) {\n                    amounts[i] = _inputAmount;\n                    uint256 _before = token3CRV.balanceOf(address(this));\n                    stableSwap3Pool.add_liquidity(amounts, _estimatedOutput);\n                    uint256 _after = token3CRV.balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    token3CRV.safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else if (_input == address(token3CRV)) { // convert from 3CRV\n            // A temporary cache, used to save gas.\n            IERC20 _token;\n            for (uint8 i = 0; i < 3; i++) {\n                _token = tokens[i];\n                if (_output == address(_token)) {\n                    uint256 _before = _token.balanceOf(address(this));\n                    stableSwap3Pool.remove_liquidity_one_coin(\n                        _inputAmount,\n                        i,\n                        _estimatedOutput\n                    );\n                    uint256 _after = _token.balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    _token.safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else {\n            stableSwap3Pool.exchange(\n                indices[_input],\n                indices[_output],\n                _inputAmount,\n                _estimatedOutput\n            );\n            _outputAmount = IERC20(_output).balanceOf(address(this));\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n            return _outputAmount;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Checks the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     */\n    function expected(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    )\n        external\n        override\n        view\n        returns (uint256)\n    {\n        if (_output == address(token3CRV)) { // convert to 3CRV\n            uint256[3] memory amounts;\n            for (uint8 i = 0; i < 3; i++) {\n                if (_input == address(tokens[i])) {\n                    amounts[i] = _inputAmount;\n                    return stableSwap3Pool.calc_token_amount(amounts, true);\n                }\n            }\n        } else if (_input == address(token3CRV)) { // convert from 3CRV\n            for (uint8 i = 0; i < 3; i++) {\n                if (_output == address(tokens[i])) {\n                    // @dev this is for UI reference only, the actual share price\n                    // (stable/CRV) will be re-calculated on-chain when we do convert()\n                    return stableSwap3Pool.calc_withdraw_one_coin(_inputAmount, i);\n                }\n            }\n        } else {\n            return stableSwap3Pool.get_dy(indices[_input], indices[_output], _inputAmount);\n        }\n        return 0;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @dev Throws if not called by an allowed vault, controller, or strategy\n     */\n    modifier onlyAuthorized() {\n        require(manager.allowedVaults(msg.sender)\n            || manager.allowedControllers(msg.sender)\n            || manager.allowedStrategies(msg.sender),\n            \"!authorized\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if not called by the strategist\n     */\n    modifier onlyStrategist {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/interfaces/ICurve3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface ICurve3Pool {\n    function get_virtual_price() external view returns (uint);\n    function balances(uint) external view returns (uint);\n    function get_dy(int128 i, int128 j, uint dx) external view returns (uint dy);\n    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;\n    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;\n    function remove_liquidity(uint _amount, uint[3] calldata amounts) external;\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;\n    function calc_token_amount(uint[3] calldata amounts, bool deposit) external view returns (uint);\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);\n}\n"
    },
    "contracts/v3/converters/GeneralConverter.sol": {
      "content": "pragma solidity 0.6.12;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n// SPDX-License-Identifier: MIT\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nimport '../interfaces/IConverter.sol';\nimport '../interfaces/IManager.sol';\nimport '../interfaces/ICurvePool.sol';\nimport '../interfaces/ICurve2Pool.sol';\nimport '../interfaces/ICurve3Pool.sol';\n\n/**\n * @title GeneralConverter\n */\ncontract GeneralConverter is IConverter {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IManager public immutable override manager;\n    ICurvePool public immutable swapPool;\n    IERC20 public immutable tokenCRV;\n\n    IERC20[] public tokens;\n\n    mapping(address => int128) internal indices;\n\n    /**\n     * @param _coinCount The number of coins in the pool\n     * @param _tokenCRV The address of the CRV token\n     * @param _swapPool The address of swap pool\n     * @param _manager The address of the Vault Manager\n     */\n    constructor(\n        uint256 _coinCount,\n        IERC20 _tokenCRV,\n        ICurvePool _swapPool,\n        IManager _manager\n    ) public {\n        require(_coinCount == 2 || _coinCount == 3, '_coinCount should be 2 or 3');\n\n        tokenCRV = _tokenCRV;\n        swapPool = _swapPool;\n        manager = _manager;\n\n        for (uint256 i = 0; i < _coinCount; i++) {\n            tokens.push(IERC20(_swapPool.coins(i)));\n            indices[address(tokens[i])] = int128(i);\n            tokens[i].safeApprove(address(_swapPool), type(uint256).max);\n        }\n\n        _tokenCRV.safeApprove(address(_swapPool), type(uint256).max);\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Called by the strategist to approve a token address to be spent by an address\n     * @param _token The address of the token\n     * @param _spender The address of the spender\n     * @param _amount The amount to spend\n     */\n    function approveForSpender(\n        IERC20 _token,\n        address _spender,\n        uint256 _amount\n    ) external onlyStrategist {\n        _token.safeApprove(_spender, _amount);\n    }\n\n    /**\n     * @notice Allows the strategist to withdraw tokens from the converter\n     * @dev This contract should never have any tokens in it at the end of a transaction\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to receive the tokens\n     */\n    function recoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    ) external onlyStrategist {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * AUTHORIZED-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Converts the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     * @param _estimatedOutput The estimated output tokens after converting\n     */\n    function convert(\n        address _input,\n        address _output,\n        uint256 _inputAmount,\n        uint256 _estimatedOutput\n    ) external override onlyAuthorized returns (uint256 _outputAmount) {\n        if (_output == address(tokenCRV)) {\n            // convert to CRV\n            for (uint8 i = 0; i < tokens.length; i++) {\n                if (_input == address(tokens[i])) {\n                    uint256 _before = tokenCRV.balanceOf(address(this));\n\n                    if (tokens.length == 2) {\n                        uint256[2] memory amounts;\n                        amounts[i] = _inputAmount;\n                        ICurve2Pool(address(swapPool)).add_liquidity(\n                            amounts,\n                            _estimatedOutput\n                        );\n                    } else {\n                        uint256[3] memory amounts;\n                        amounts[i] = _inputAmount;\n                        ICurve3Pool(address(swapPool)).add_liquidity(\n                            amounts,\n                            _estimatedOutput\n                        );\n                    }\n\n                    uint256 _after = tokenCRV.balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    tokenCRV.safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else if (_input == address(tokenCRV)) {\n            // convert from CRV\n            for (uint8 i = 0; i < tokens.length; i++) {\n                if (_output == address(tokens[i])) {\n                    uint256 _before = tokens[i].balanceOf(address(this));\n                    swapPool.remove_liquidity_one_coin(_inputAmount, i, _estimatedOutput);\n                    uint256 _after = tokens[i].balanceOf(address(this));\n                    _outputAmount = _after.sub(_before);\n                    tokens[i].safeTransfer(msg.sender, _outputAmount);\n                    return _outputAmount;\n                }\n            }\n        } else {\n            swapPool.exchange(\n                indices[_input],\n                indices[_output],\n                _inputAmount,\n                _estimatedOutput\n            );\n            _outputAmount = IERC20(_output).balanceOf(address(this));\n            IERC20(_output).safeTransfer(msg.sender, _outputAmount);\n            return _outputAmount;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Checks the amount of input tokens to output tokens\n     * @param _input The address of the token being converted\n     * @param _output The address of the token to be converted to\n     * @param _inputAmount The input amount of tokens that are being converted\n     */\n    function expected(\n        address _input,\n        address _output,\n        uint256 _inputAmount\n    ) external view override returns (uint256) {\n        if (_output == address(tokenCRV)) {\n            // convert to CRV\n            for (uint8 i = 0; i < tokens.length; i++) {\n                if (_input == address(tokens[i])) {\n                    if (tokens.length == 2) {\n                        uint256[2] memory amounts;\n                        amounts[i] = _inputAmount;\n                        return ICurve2Pool(address(swapPool)).calc_token_amount(amounts, true);\n                    } else {\n                        uint256[3] memory amounts;\n                        amounts[i] = _inputAmount;\n                        return ICurve3Pool(address(swapPool)).calc_token_amount(amounts, true);\n                    }\n                }\n            }\n        } else if (_input == address(tokenCRV)) {\n            // convert from CRV\n            for (uint8 i = 0; i < tokens.length; i++) {\n                if (_output == address(tokens[i])) {\n                    // @dev this is for UI reference only, the actual share price\n                    // (stable/CRV) will be re-calculated on-chain when we do convert()\n                    return swapPool.calc_withdraw_one_coin(_inputAmount, i);\n                }\n            }\n        } else {\n            return swapPool.get_dy(indices[_input], indices[_output], _inputAmount);\n        }\n        return 0;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @dev Throws if not called by an allowed vault, controller, or strategy\n     */\n    modifier onlyAuthorized() {\n        require(\n            manager.allowedVaults(msg.sender) ||\n                manager.allowedControllers(msg.sender) ||\n                manager.allowedStrategies(msg.sender),\n            '!authorized'\n        );\n        _;\n    }\n\n    /**\n     * @dev Throws if not called by the strategist\n     */\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), '!strategist');\n        _;\n    }\n}\n"
    },
    "contracts/v3/interfaces/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n\n    function coins(uint256) external view returns (address);\n\n    function balances(uint256) external view returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256 dy);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/v3/interfaces/ICurve2Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\ninterface ICurve2Pool {\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[2] calldata amounts) external;\n\n    function calc_token_amount(uint256[2] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/v3/VaultToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../vendor/LinkToken/token/LinkERC20.sol\";\nimport \"../vendor/LinkToken/ERC677Token.sol\";\n\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IVaultToken.sol\";\n\n/**\n * @notice Vault Token\n * @dev Contract has been copied from:\n * https://github.com/smartcontractkit/LinkToken/blob/master/contracts/v0.6/LinkToken.sol\n * with modification made to specify name and symbol, deploys with 0 total supply\n */\ncontract VaultToken is IVaultToken, LinkERC20, ERC677Token {\n\n    IManager public immutable manager;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _manager\n    )\n        public\n        ERC20(_name, _symbol)\n    // solhint-disable-next-line no-empty-blocks\n    {\n        manager = IManager(_manager);\n    }\n\n    function mint(\n        address _account,\n        uint256 _amount\n    )\n        external\n        override\n        onlyVault\n    {\n        _mint(_account, _amount);\n    }\n\n    function burn(\n        address _account,\n        uint256 _amount\n    )\n        external\n        override\n        onlyVault\n    {\n        _burn(_account, _amount);\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount)\n        internal\n        override\n        virtual\n        validAddress(recipient)\n    {\n        super._transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount)\n        internal\n        override\n        virtual\n        validAddress(spender)\n    {\n        super._approve(owner, spender, amount);\n    }\n\n\n    // MODIFIERS\n\n    modifier validAddress(address _recipient) {\n        require(_recipient != address(this), \"!validAddress\");\n        _;\n    }\n\n    modifier onlyVault() {\n        require(manager.allowedVaults(msg.sender), \"!vault\");\n        _;\n    }\n}\n"
    },
    "contracts/vendor/LinkToken/token/LinkERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nabstract contract LinkERC20 is ERC20 {\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseApproval(address spender, uint256 addedValue) public virtual returns (bool) {\n    return super.increaseAllowance(spender, addedValue);\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseApproval(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    return super.decreaseAllowance(spender, subtractedValue);\n  }\n}\n"
    },
    "contracts/vendor/LinkToken/ERC677Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./token/ERC677.sol\";\nimport \"./token/ERC677Receiver.sol\";\n\nabstract contract ERC677Token is ERC20, ERC677 {\n  /**\n   * @dev transfer token to a contract address with additional data if the recipient is a contact.\n   * @param _to The address to transfer to.\n   * @param _value The amount to be transferred.\n   * @param _data The extra data to be passed to the receiving contract.\n   */\n  function transferAndCall(address _to, uint _value, bytes memory _data)\n    public\n    override\n    virtual\n    returns (bool success)\n  {\n    super.transfer(_to, _value);\n    emit Transfer(msg.sender, _to, _value, _data);\n    if (isContract(_to)) {\n      contractFallback(_to, _value, _data);\n    }\n    return true;\n  }\n\n\n  // PRIVATE\n\n  function contractFallback(address _to, uint _value, bytes memory _data)\n    private\n  {\n    ERC677Receiver receiver = ERC677Receiver(_to);\n    receiver.onTokenTransfer(msg.sender, _value, _data);\n  }\n\n  function isContract(address _addr)\n    private\n    view\n    returns (bool hasCode)\n  {\n    uint length;\n    assembly { length := extcodesize(_addr) }\n    return length > 0;\n  }\n}\n"
    },
    "contracts/vendor/LinkToken/token/ERC677.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract ERC677 is IERC20 {\n  function transferAndCall(address to, uint value, bytes memory data) public virtual returns (bool success);\n\n  event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\n"
    },
    "contracts/vendor/LinkToken/token/ERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nabstract contract ERC677Receiver {\n  function onTokenTransfer(address _sender, uint _value, bytes memory _data) public virtual;\n}\n"
    },
    "contracts/token/YaxisToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../vendor/LinkToken/token/LinkERC20.sol\";\nimport \"../vendor/LinkToken/ERC677Token.sol\";\n\n/**\n * @notice yAxis Token\n * @dev Contract has been copied from:\n * https://github.com/smartcontractkit/LinkToken/blob/master/contracts/v0.6/LinkToken.sol\n * with modifications only made to TOTAL_SUPPLY, NAME, SYMBOL, and the validAddress\n * modifier's revert message.\n */\ncontract YaxisToken is LinkERC20, ERC677Token {\n    uint256 private constant TOTAL_SUPPLY = 11*10**24;\n    string private constant NAME = \"yAxis V2\";\n    string private constant SYMBOL = \"YAXIS\";\n\n    constructor()\n        public\n        ERC20(NAME, SYMBOL)\n    {\n        _onCreate();\n    }\n\n    /**\n     * @dev Hook that is called when this contract is created.\n     * Useful to override constructor behaviour in child contracts (e.g., LINK bridge tokens).\n     * @notice Default implementation mints 10**27 tokens to msg.sender\n     */\n    function _onCreate()\n        internal\n        virtual\n    {\n        _mint(msg.sender, TOTAL_SUPPLY);\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount)\n        internal\n        override\n        virtual\n        validAddress(recipient)\n    {\n        super._transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount)\n        internal\n        override\n        virtual\n        validAddress(spender)\n    {\n        super._approve(owner, spender, amount);\n    }\n\n\n    // MODIFIERS\n\n    modifier validAddress(address _recipient) {\n        require(_recipient != address(this), \"!validAddress\");\n        _;\n    }\n}\n"
    },
    "contracts/token/mock/MockERC677.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"../../vendor/LinkToken/token/LinkERC20.sol\";\nimport \"../../vendor/LinkToken/ERC677Token.sol\";\n\ncontract MockERC677 is LinkERC20, ERC677Token {\n\n    constructor(\n        string memory _name,\n        string memory _symbol\n    )\n        public\n        ERC20(_name, _symbol)\n    {}\n\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        external\n    {\n        _mint(_to, _amount);\n    }\n\n    function faucet(\n        uint256 _amount\n    )\n        external\n    {\n        _mint(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount)\n        internal\n        override\n        virtual\n        validAddress(recipient)\n    {\n        super._transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount)\n        internal\n        override\n        virtual\n        validAddress(spender)\n    {\n        super._approve(owner, spender, amount);\n    }\n\n\n    // MODIFIERS\n\n    modifier validAddress(address _recipient) {\n        require(_recipient != address(this), \"!validAddress\");\n        _;\n    }\n}\n"
    },
    "contracts/token/Rewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable reason-string\n// solhint-disable not-rely-on-time\n/**\n * This contract has been modified with:\n * - generalized for any reward token, staking token, and duration\n * - upgraded to Solidity 6\n * - support ERC677 transferAndCall\n * <3 Synthetix\n */\n\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: CurveRewards.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../vendor/LinkToken/token/ERC677Receiver.sol\";\n\nabstract contract IRewardDistributionRecipient is Ownable {\n    address public rewardDistribution;\n\n    function notifyRewardAmount(uint256 reward) external virtual;\n\n    modifier onlyRewardDistribution() {\n        require(_msgSender() == rewardDistribution, \"Caller is not reward distribution\");\n        _;\n    }\n\n    function setRewardDistribution(address _rewardDistribution)\n        external\n        onlyOwner\n    {\n        rewardDistribution = _rewardDistribution;\n    }\n}\n\ncontract LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable stakingToken;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    constructor(\n        address _stakingToken\n    )\n        public\n    {\n        stakingToken = IERC20(_stakingToken);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function stakeFor(address account, uint256 amount) internal {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        // we don't transferFrom here because this is only triggered\n        // when tokens have already been received\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract Rewards is LPTokenWrapper, IRewardDistributionRecipient, ERC677Receiver {\n    IERC20 public immutable rewardToken;\n    uint256 public immutable duration;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(\n        address _rewardToken,\n        address _stakingToken,\n        uint256 _duration\n    )\n        public\n        LPTokenWrapper(_stakingToken)\n    {\n        rewardToken = IERC20(_rewardToken);\n        duration = _duration;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function onTokenTransfer(address sender, uint256 amount, bytes memory)\n        public override updateReward(sender)\n    {\n        require(msg.sender == address(stakingToken), \"!stakingToken\");\n        super.stakeFor(sender, amount);\n        emit Staked(sender, amount);\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(duration);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/mock/MockGenericVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./MockERC20.sol\";\nimport \"../interfaces/GenericVault.sol\";\n\ncontract MockGenericVault is MockERC20 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    IERC20 public token;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    constructor (address _token) public MockERC20(\n        string(abi.encodePacked(\"Generic Vault \", ERC20(_token).name())),\n        string(abi.encodePacked(\"v\", ERC20(_token).symbol())),\n        ERC20(_token).decimals()\n    ) {\n        token = IERC20(_token);\n    }\n\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this));\n    }\n\n    function available() public view returns (uint) {\n        return token.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    function deposit(uint _amount) public {\n        uint _pool = balance();\n        uint _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before);\n        uint shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    function withdraw(uint _shares) public {\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n        token.safeTransfer(msg.sender, r);\n    }\n\n    function getPricePerFullShare() public view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n}\n"
    },
    "contracts/interfaces/GenericVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface IGenericVault {\n    function token() external view returns (address);\n    function getPricePerFullShare() external view returns (uint256);\n    function deposit(uint256) external;\n    function withdraw(uint256) external;\n    function depositAll() external;\n    function withdrawAll() external;\n}\n"
    },
    "contracts/mock/MockPickleJar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/PickleJar.sol\";\nimport \"./MockERC20.sol\";\n\ncontract MockPickleJar is MockERC20 {\n    IERC20 public t3crv;\n    IERC20 public lpToken;\n\n    constructor(IERC20 _t3crv) public MockERC20(\"pickling Curve.fi DAI/USDC/USDT\", \"p3Crv\", 18) {\n        t3crv = _t3crv;\n    }\n\n    function balance() public view returns (uint) {\n        return t3crv.balanceOf(address(this));\n    }\n\n    function available() external view returns (uint) {\n        return balance() * 9500 / 10000;\n    }\n\n    function depositAll() external {\n        deposit(t3crv.balanceOf(msg.sender));\n    }\n\n    function deposit(uint _amount) public {\n        t3crv.transferFrom(msg.sender, address(this), _amount);\n        uint256 shares = _amount * 1000000000000000000 / getRatio();\n        _mint(msg.sender, shares);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    function withdraw(uint _shares) public {\n        uint256 r = _shares * getRatio() / 1000000000000000000;\n        _burn(msg.sender, _shares);\n        t3crv.transfer(msg.sender, r);\n    }\n\n    function getRatio() public pure returns (uint) {\n        return 1010000000000000000; // +1%\n    }\n}\n"
    },
    "contracts/interfaces/PickleJar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\ninterface PickleJar {\n    function balanceOf(address account) external view returns (uint);\n    function balance() external view returns (uint);\n    function available() external view returns (uint);\n    function depositAll() external;\n    function deposit(uint _amount) external;\n    function withdrawAll() external;\n    function withdraw(uint _shares) external;\n    function getRatio() external view returns (uint);\n}\n"
    },
    "contracts/mock/MockFlamIncome.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./MockERC20.sol\";\n\ncontract MockFlamIncomeVault is MockERC20 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    IERC20 public token;\n\n    uint public min = 9500;\n    uint public constant max = 10000;\n\n    constructor (address _token) public MockERC20(\n        string(abi.encodePacked(\"flamincomed \", ERC20(_token).name())),\n        string(abi.encodePacked(\"f\", ERC20(_token).symbol())),\n        ERC20(_token).decimals()\n    ) {\n        token = IERC20(_token);\n    }\n\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this));\n    }\n\n    function available() public view returns (uint) {\n        return token.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    function deposit(uint _amount) public {\n        uint _pool = balance();\n        uint _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before);\n        uint shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    function withdraw(uint _shares) public {\n        uint r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n        token.safeTransfer(msg.sender, r);\n    }\n\n    function priceE18() public view returns (uint) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n}\n"
    },
    "contracts/mock/MockdYdXSoloMargin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/dYdXSoloMargin.sol\";\n\ncontract MockdYdXSoloMargin is ISoloMargin {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n\n    // Store balances as (Account => (MarketID => balance))\n    mapping(address => mapping(uint256 => uint128)) balances;\n\n    // Mapping of tokens as (MarketID => token)\n    mapping(uint256 => address) tokens;\n\n    constructor (uint256[] memory _marketIds, address[] memory _addresses) public {\n        require(_marketIds.length == _addresses.length, \"marketIds.length != addresses.length\");\n        for (uint256 i = 0; i < _marketIds.length; i++) {\n            tokens[_marketIds[i]] = _addresses[i];\n        }\n    }\n\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) public override {\n        _verifyInputs(accounts, actions);\n\n        _runActions(\n            accounts,\n            actions\n        );\n    }\n\n    function _verifyInputs(\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions\n    ) private pure {\n        require(actions.length != 0, \"Cannot have zero actions\");\n        require(accounts.length != 0, \"Cannot have zero accounts\");\n\n        for (uint256 a = 0; a < accounts.length; a++) {\n            for (uint256 b = a + 1; b < accounts.length; b++) {\n                require(!Account.equals(accounts[a], accounts[b]), \"Cannot duplicate accounts\");\n            }\n        }\n    }\n\n    function _runActions(\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions\n    ) private {\n        for (uint256 i = 0; i < actions.length; i++) {\n            Actions.ActionArgs memory action = actions[i];\n            Actions.ActionType actionType = action.actionType;\n\n            if (actionType == Actions.ActionType.Deposit) {\n                _deposit(Actions.parseDepositArgs(accounts, action));\n            } else if (actionType == Actions.ActionType.Withdraw) {\n                _withdraw(Actions.parseWithdrawArgs(accounts, action));\n            }\n        }\n    }\n\n    function _deposit(\n        Actions.DepositArgs memory args\n    )\n        private\n    {\n        require(\n            args.from == msg.sender || args.from == args.account.owner,\n            \"Invalid deposit source\"\n        );\n\n        // We'll not implement all cases in this mock, for simplicity\n        require(args.amount.denomination == Types.AssetDenomination.Wei, \"!Types.AssetDenomination.Wei\");\n        IERC20(tokens[args.market]).safeTransferFrom(args.from, address(this), args.amount.value);\n\n        uint128 newBalance = to128(SafeMath.add(balances[args.account.owner][args.market], args.amount.value));\n        balances[args.account.owner][args.market] = newBalance;\n    }\n\n    function _withdraw(\n        Actions.WithdrawArgs memory args\n    )\n        private\n    {\n        require(\n            msg.sender == args.account.owner,\n            \"Not valid operator\"\n        );\n        require(args.amount.value <= balances[args.account.owner][args.market], \"!balance\");\n        require(!args.amount.sign, \"should receive negative amount\");\n        IERC20(tokens[args.market]).safeTransfer(args.to, args.amount.value);\n\n        uint128 newBalance = to128(SafeMath.sub(balances[args.account.owner][args.market], args.amount.value));\n        balances[args.account.owner][args.market] = newBalance;\n    }\n\n    function getMarketTokenAddress(uint256 marketId) external override view returns (address) {\n        return tokens[marketId];\n    }\n\n    function getAccountWei(Account.Info memory account, uint256 marketId)\n        external\n        override\n        view\n        returns (Types.Wei memory)\n    {\n        Types.Wei memory balance = Types.Wei({\n            sign: true,\n            value: balances[account.owner][marketId]\n        });\n        return balance;\n    }\n\n    function to128(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 result = uint128(number);\n        require(result == number, \"Unsafe cast to uint128\");\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/dYdXSoloMargin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\npragma experimental ABIEncoderV2;\n\nlibrary Account {\n    enum Status {\n        Normal,\n        Liquid,\n        Vapor\n    }\n\n    struct Info {\n        address owner;  // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n\n    function equals(\n        Info memory a,\n        Info memory b\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return a.owner == b.owner && a.number == b.number;\n    }\n}\n\nlibrary Types {\n    enum AssetDenomination {\n        Wei // the amount is denominated in wei\n    }\n\n    struct Wei {\n        bool sign; // true if positive\n        uint256 value;\n    }\n\n    enum AssetReference {\n        Delta // the amount is given as a delta from the current value\n    }\n\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n}\n\nlibrary Actions {\n    enum ActionType {\n        Deposit, // supply tokens\n        Withdraw // borrow tokens\n    }\n\n    enum AccountLayout {\n        OnePrimary,\n        TwoPrimary,\n        PrimaryAndSecondary\n    }\n\n    enum MarketLayout {\n        ZeroMarkets,\n        OneMarket,\n        TwoMarkets\n    }\n\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        Types.AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n\n    struct DepositArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 market;\n        address from;\n    }\n\n    struct WithdrawArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 market;\n        address to;\n    }\n\n    function parseDepositArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (DepositArgs memory)\n    {\n        assert(args.actionType == ActionType.Deposit);\n        return DepositArgs({\n            amount: args.amount,\n            account: accounts[args.accountId],\n            market: args.primaryMarketId,\n            from: args.otherAddress\n        });\n    }\n\n    function parseWithdrawArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (WithdrawArgs memory)\n    {\n        assert(args.actionType == ActionType.Withdraw);\n        return WithdrawArgs({\n            amount: args.amount,\n            account: accounts[args.accountId],\n            market: args.primaryMarketId,\n            to: args.otherAddress\n        });\n    }\n}\n\ninterface ISoloMargin {\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\n    function getMarketTokenAddress(uint256 marketId) external view returns (address);\n    function getAccountWei(Account.Info memory account, uint256 marketId) external view returns (Types.Wei memory);\n}\n"
    },
    "contracts/v3/Manager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable max-states-count\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title Manager\n * @notice This contract serves as the central point for governance-voted\n * variables. Fees and permissioned addresses are stored and referenced in\n * this contract only.\n */\ncontract Manager is IManager {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;\n    uint256 public constant MAX_TOKENS = 256;\n\n    address public immutable override yaxis;\n\n    bool public override halted;\n\n    address public override governance;\n    address public override harvester;\n    address public override insurancePool;\n    address public override stakingPool;\n    address public override strategist;\n    address public override pendingStrategist;\n    address public override treasury;\n\n    // The following fees are all mutable.\n    // They are updated by governance (community vote).\n    uint256 public override insuranceFee;\n    uint256 public override insurancePoolFee;\n    uint256 public override stakingPoolShareFee;\n    uint256 public override treasuryFee;\n    uint256 public override withdrawalProtectionFee;\n\n\n    uint256 private setPendingStrategistTime;\n\n    // Governance must first allow the following properties before\n    // the strategist can make use of them\n    mapping(address => bool) public override allowedControllers;\n    mapping(address => bool) public override allowedConverters;\n    mapping(address => bool) public override allowedStrategies;\n    mapping(address => bool) public override allowedVaults;\n\n    // vault => controller\n    mapping(address => address) public override controllers;\n    // vault => token\n    mapping(address => address) internal tokens;\n\n    event AllowedController(\n        address indexed _controller,\n        bool _allowed\n    );\n    event AllowedConverter(\n        address indexed _converter,\n        bool _allowed\n    );\n    event AllowedStrategy(\n        address indexed _strategy,\n        bool _allowed\n    );\n    event AllowedVault(\n        address indexed _vault,\n        bool _allowed\n    );\n    event Halted();\n    event SetController(\n        address indexed _vault,\n        address indexed _controller\n    );\n    event SetGovernance(\n        address indexed _governance\n    );\n    event SetPendingStrategist(\n        address indexed _strategist\n    );\n    event SetStrategist(\n        address indexed _strategist\n    );\n    event VaultAdded(\n        address indexed _vault,\n        address indexed _token\n    );\n    event VaultRemoved(\n        address indexed _vault\n    );\n\n    /**\n     * @param _yaxis The address of the YAX token\n     */\n    constructor(\n        address _yaxis\n    )\n        public\n    {\n        require(_yaxis != address(0), \"!_yaxis\");\n        yaxis = _yaxis;\n        governance = msg.sender;\n        strategist = msg.sender;\n        harvester = msg.sender;\n        treasury = msg.sender;\n        stakingPoolShareFee = 2000;\n        treasuryFee = 500;\n        withdrawalProtectionFee = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the permission for the given controller\n     * @param _controller The address of the controller\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedController(\n        address _controller,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IController(_controller).manager()) == address(this), \"!manager\");\n        allowedControllers[_controller] = _allowed;\n        emit AllowedController(_controller, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given converter\n     * @param _converter The address of the converter\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedConverter(\n        address _converter,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IConverter(_converter).manager()) == address(this), \"!manager\");\n        allowedConverters[_converter] = _allowed;\n        emit AllowedConverter(_converter, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given strategy\n     * @param _strategy The address of the strategy\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedStrategy(\n        address _strategy,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IStrategy(_strategy).manager()) == address(this), \"!manager\");\n        allowedStrategies[_strategy] = _allowed;\n        emit AllowedStrategy(_strategy, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given vault\n     * @param _vault The address of the vault\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedVault(\n        address _vault,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IVault(_vault).manager()) == address(this), \"!manager\");\n        allowedVaults[_vault] = _allowed;\n        emit AllowedVault(_vault, _allowed);\n    }\n\n    /**\n     * @notice Sets the governance address\n     * @param _governance The address of the governance\n     */\n    function setGovernance(\n        address _governance\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        governance = _governance;\n        emit SetGovernance(_governance);\n    }\n\n    /**\n     * @notice Sets the harvester address\n     * @param _harvester The address of the harvester\n     */\n    function setHarvester(\n        address _harvester\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IHarvester(_harvester).manager()) == address(this), \"!manager\");\n        harvester = _harvester;\n    }\n\n    /**\n     * @notice Sets the insurance fee\n     * @dev Throws if setting fee over 1%\n     * @param _insuranceFee The value for the insurance fee\n     */\n    function setInsuranceFee(\n        uint256 _insuranceFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insuranceFee <= 100, \"_insuranceFee over 1%\");\n        insuranceFee = _insuranceFee;\n    }\n\n    /**\n     * @notice Sets the insurance pool address\n     * @param _insurancePool The address of the insurance pool\n     */\n    function setInsurancePool(\n        address _insurancePool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        insurancePool = _insurancePool;\n    }\n\n    /**\n     * @notice Sets the insurance pool fee\n     * @dev Throws if setting fee over 20%\n     * @param _insurancePoolFee The value for the insurance pool fee\n     */\n    function setInsurancePoolFee(\n        uint256 _insurancePoolFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insurancePoolFee <= 2000, \"_insurancePoolFee over 20%\");\n        insurancePoolFee = _insurancePoolFee;\n    }\n\n    /**\n     * @notice Sets the staking pool address\n     * @param _stakingPool The address of the staking pool\n     */\n    function setStakingPool(\n        address _stakingPool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        stakingPool = _stakingPool;\n    }\n\n    /**\n     * @notice Sets the staking pool share fee\n     * @dev Throws if setting fee over 50%\n     * @param _stakingPoolShareFee The value for the staking pool fee\n     */\n    function setStakingPoolShareFee(\n        uint256 _stakingPoolShareFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_stakingPoolShareFee <= 5000, \"_stakingPoolShareFee over 50%\");\n        stakingPoolShareFee = _stakingPoolShareFee;\n    }\n\n    /**\n     * @notice Sets the pending strategist and the timestamp\n     * @param _strategist The address of the strategist\n     */\n    function setStrategist(\n        address _strategist\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_strategist != address(0), \"!_strategist\");\n        pendingStrategist = _strategist;\n        // solhint-disable-next-line not-rely-on-time\n        setPendingStrategistTime = block.timestamp;\n        emit SetPendingStrategist(_strategist);\n    }\n\n    /**\n     * @notice Sets the treasury address\n     * @param _treasury The address of the treasury\n     */\n    function setTreasury(\n        address _treasury\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasury != address(0), \"!_treasury\");\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Sets the treasury fee\n     * @dev Throws if setting fee over 20%\n     * @param _treasuryFee The value for the treasury fee\n     */\n    function setTreasuryFee(\n        uint256 _treasuryFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasuryFee <= 2000, \"_treasuryFee over 20%\");\n        treasuryFee = _treasuryFee;\n    }\n\n    /**\n     * @notice Sets the withdrawal protection fee\n     * @dev Throws if setting fee over 1%\n     * @param _withdrawalProtectionFee The value for the withdrawal protection fee\n     */\n    function setWithdrawalProtectionFee(\n        uint256 _withdrawalProtectionFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_withdrawalProtectionFee <= 100, \"_withdrawalProtectionFee over 1%\");\n        withdrawalProtectionFee = _withdrawalProtectionFee;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Updates the strategist to the pending strategist\n     * @dev This can only be called after the pending strategist timelock (7 days)\n     */\n    function acceptStrategist()\n        external\n        notHalted\n    {\n        require(msg.sender == pendingStrategist, \"!pendingStrategist\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), \"PENDING_STRATEGIST_TIMELOCK\");\n        delete pendingStrategist;\n        delete setPendingStrategistTime;\n        strategist = msg.sender;\n        emit SetStrategist(msg.sender);\n    }\n\n    /**\n     * @notice Adds a token to be able to be deposited for a given vault\n     * @param _vault The address of the vault\n     */\n    function addVault(\n        address _vault\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        require(allowedVaults[_vault], \"!allowedVaults\");\n        require(tokens[_vault] == address(0), \"!_vault\");\n        address _token = IVault(_vault).getToken();\n        tokens[_vault] = _token;\n        emit VaultAdded(_vault, _token);\n    }\n\n    /**\n     * @notice Allows the strategist to pull tokens out of this contract\n     * @dev This contract should never hold tokens\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to send to\n     */\n    function recoverToken(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice Removes a token from being able to be deposited for a given vault\n     * @param _vault The address of the vault\n     */\n    function removeVault(\n        address _vault\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        require(tokens[_vault] != address(0), \"!_vault\");\n        delete tokens[_vault];\n        delete allowedVaults[_vault];\n        emit VaultRemoved(_vault);\n    }\n\n    /**\n     * @notice Sets the vault address for a controller\n     * @param _vault The address of the vault\n     * @param _controller The address of the controller\n     */\n    function setController(\n        address _vault,\n        address _controller\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(allowedVaults[_vault], \"!_vault\");\n        require(allowedControllers[_controller], \"!_controller\");\n        controllers[_vault] = _controller;\n        emit SetController(_vault, _controller);\n    }\n\n    /**\n     * @notice Sets the protocol as halted, disallowing all deposits forever\n     * @dev Withdraws will still work, allowing users to exit the protocol\n     */\n    function setHalted()\n        external\n        notHalted\n        onlyStrategist\n    {\n        halted = true;\n        emit Halted();\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns an array of token addresses for a given vault\n     * @param _vault The address of the vault\n     */\n    function getToken(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address)\n    {\n        return tokens[_vault];\n    }\n\n    /**\n     * @notice Returns a tuple of:\n     *     YAXIS token address,\n     *     Treasury address,\n     *     Treasury fee\n     */\n    function getHarvestFeeInfo()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        return (\n            yaxis,\n            treasury,\n            treasuryFee\n        );\n    }\n\n    modifier notHalted() {\n        require(!halted, \"halted\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"!governance\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == strategist, \"!strategist\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/interfaces/IHarvester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IManager.sol\";\n\ninterface IHarvester {\n    function addStrategy(address, address, uint256) external;\n    function manager() external view returns (IManager);\n    function removeStrategy(address, address, uint256) external;\n}\n\n"
    },
    "contracts/v3/Harvester.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/ILegacyController.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/ISwap.sol\";\n\n/**\n * @title Harvester\n * @notice This contract is to be used as a central point to call\n * harvest on all strategies for any given vault. It has its own\n * permissions for harvesters (set by the strategist or governance).\n */\ncontract Harvester is IHarvester {\n    using SafeMath for uint256;\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\n\n    IManager public immutable override manager;\n    IController public immutable controller;\n    ILegacyController public immutable legacyController;\n\n    uint256 public slippage;\n\n    struct Strategy {\n        uint256 timeout;\n        uint256 lastCalled;\n        address[] addresses;\n    }\n\n    mapping(address => Strategy) public strategies;\n    mapping(address => bool) public isHarvester;\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(\n        address indexed controller,\n        address indexed strategy\n    );\n\n    /**\n     * @notice Logged when a harvester is set\n     */\n    event HarvesterSet(address indexed harvester, bool status);\n\n    /**\n     * @notice Logged when a strategy is added for a vault\n     */\n    event StrategyAdded(address indexed vault, address indexed strategy, uint256 timeout);\n\n    /**\n     * @notice Logged when a strategy is removed for a vault\n     */\n    event StrategyRemoved(address indexed vault, address indexed strategy, uint256 timeout);\n\n    /**\n     * @param _manager The address of the yAxisMetaVaultManager contract\n     * @param _controller The address of the controller\n     */\n    constructor(\n        address _manager,\n        address _controller,\n        address _legacyController\n    )\n        public\n    {\n        manager = IManager(_manager);\n        controller = IController(_controller);\n        legacyController = ILegacyController(_legacyController);\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy to the rotation for a given vault and sets a timeout\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        override\n        onlyController\n    {\n        strategies[_vault].addresses.push(_strategy);\n        strategies[_vault].timeout = _timeout;\n        emit StrategyAdded(_vault, _strategy, _timeout);\n    }\n\n    /**\n     * @notice Removes a strategy from the rotation for a given vault and sets a timeout\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        override\n        onlyController\n    {\n        uint256 tail = strategies[_vault].addresses.length;\n        uint256 index;\n        bool found;\n        for (uint i; i < tail; i++) {\n            if (strategies[_vault].addresses[i] == _strategy) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n\n        if (found) {\n            strategies[_vault].addresses[index] = strategies[_vault].addresses[tail.sub(1)];\n            strategies[_vault].addresses.pop();\n            strategies[_vault].timeout = _timeout;\n            emit StrategyRemoved(_vault, _strategy, _timeout);\n        }\n    }\n\n    /**\n     * @notice Sets the status of a harvester address to be able to call harvest functions\n     * @param _harvester The address of the harvester\n     * @param _status The status to allow the harvester to harvest\n     */\n    function setHarvester(\n        address _harvester,\n        bool _status\n    )\n        external\n        onlyStrategist\n    {\n        isHarvester[_harvester] = _status;\n        emit HarvesterSet(_harvester, _status);\n    }\n\n    function setSlippage(\n        uint256 _slippage\n    )\n        external\n        onlyStrategist\n    {\n        require(_slippage < ONE_HUNDRED_PERCENT, \"!_slippage\");\n        slippage = _slippage;\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    function earn(\n        address _strategy,\n        address _vault\n    )\n        external\n        onlyHarvester\n    {\n        IVault(_vault).earn(_strategy);\n    }\n\n    /**\n     * @notice Harvests a given strategy on the provided controller\n     * @dev This function ignores the timeout\n     * @param _controller The address of the controller\n     * @param _strategy The address of the strategy\n     */\n    function harvest(\n        IController _controller,\n        address _strategy,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        public\n        onlyHarvester\n    {\n        _controller.harvestStrategy(_strategy, _estimatedWETH, _estimatedYAXIS);\n        emit Harvest(address(_controller), _strategy);\n    }\n\n    /**\n     * @notice Harvests the next available strategy for a given vault and\n     * rotates the strategies\n     * @param _vault The address of the vault\n     */\n    function harvestNextStrategy(\n        address _vault,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        external\n    {\n        require(canHarvest(_vault), \"!canHarvest\");\n        address strategy = strategies[_vault].addresses[0];\n        harvest(controller, strategy, _estimatedWETH, _estimatedYAXIS);\n        uint256 k = strategies[_vault].addresses.length;\n        if (k > 1) {\n            address[] memory _strategies = new address[](k);\n            for (uint i; i < k-1; i++) {\n                _strategies[i] = strategies[_vault].addresses[i+1];\n            }\n            _strategies[k-1] = strategy;\n            strategies[_vault].addresses = _strategies;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        strategies[_vault].lastCalled = block.timestamp;\n    }\n\n    /**\n     * @notice Earns tokens in the LegacyController to the v3 vault\n     * @param _expected The expected amount to deposit after conversion\n     */\n    function legacyEarn(\n        uint256 _expected\n    )\n        external\n        onlyHarvester\n    {\n        legacyController.legacyDeposit(_expected);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the addresses of the strategies for a given vault\n     * @param _vault The address of the vault\n     */\n    function strategyAddresses(\n        address _vault\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return strategies[_vault].addresses;\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the availability of a vault's strategy to be harvested\n     * @param _vault The address of the vault\n     */\n    function canHarvest(\n        address _vault\n    )\n        public\n        view\n        returns (bool)\n    {\n        Strategy storage strategy = strategies[_vault];\n        // only can harvest if there are strategies, and when sufficient time has elapsed\n        // solhint-disable-next-line not-rely-on-time\n        return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout));\n    }\n\n    /**\n     * @notice Returns the estimated amount of WETH and YAXIS for the given strategy\n     * @param _strategy The address of the strategy\n     */\n    function getEstimates(\n        address _strategy\n    )\n        public\n        view\n        returns (uint256 _estimatedWETH, uint256 _estimatedYAXIS)\n    {\n        ISwap _router = IStrategy(_strategy).router();\n        address[] memory _path;\n        _path[0] = IStrategy(_strategy).want();\n        _path[1] = IStrategy(_strategy).weth();\n        uint256[] memory _amounts = _router.getAmountsOut(\n            IStrategy(_strategy).balanceOfPool(),\n            _path\n        );\n        _estimatedWETH = _amounts[1];\n        uint256 _slippage = slippage;\n        if (_slippage > 0) {\n            _estimatedWETH = _estimatedWETH.mul(_slippage).div(ONE_HUNDRED_PERCENT);\n        }\n        _path[0] = IStrategy(_strategy).weth();\n        _path[1] = manager.yaxis();\n        uint256 _fee = _estimatedWETH.mul(manager.treasuryFee()).div(ONE_HUNDRED_PERCENT);\n        _amounts = _router.getAmountsOut(_fee, _path);\n        _estimatedYAXIS = _amounts[1];\n        if (_slippage > 0) {\n            _estimatedYAXIS = _estimatedYAXIS.mul(_slippage).div(ONE_HUNDRED_PERCENT);\n        }\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyController() {\n        require(manager.allowedControllers(msg.sender), \"!controller\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(isHarvester[msg.sender], \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/interfaces/ILegacyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ninterface ILegacyController {\n    function legacyDeposit(uint256 _expected) external;\n}\n"
    },
    "contracts/v3/controllers/LegacyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/ILegacyController.sol\";\nimport \"../interfaces/ILegacyVault.sol\";\nimport \"../interfaces/IManager.sol\";\nimport \"../interfaces/IVault.sol\";\n\ncontract LegacyController is ILegacyController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    uint256 public constant MAX = 10000;\n\n    IManager public immutable manager;\n    IERC20 public immutable token;\n    address public immutable metavault;\n\n    bool public investEnabled;\n    IVault public vault;\n    IConverter public converter;\n\n    event Earn(uint256 amount);\n    event Withdraw(uint256 amount);\n\n    /**\n     * @param _manager The vault manager contract\n     * @param _metavault The legacy MetaVault contract\n     */\n    constructor(\n        address _manager,\n        address _metavault\n    )\n        public\n    {\n        manager = IManager(_manager);\n        metavault = _metavault;\n        address _token = ILegacyVault(_metavault).want();\n        token = IERC20(_token);\n    }\n\n    /**\n     * @notice Sets the vault address\n     * @param _vault The v3 vault address\n     */\n    function setVault(\n        address _vault\n    )\n        external\n        onlyStrategist\n    {\n        IVault cachedVault = vault;\n        if (address(cachedVault) != address(0)) {\n            cachedVault.withdrawAll();\n            token.safeTransfer(metavault, token.balanceOf(address(this)));\n        }\n        vault = IVault(_vault);\n    }\n\n    /**\n     * @notice Sets the converter address\n     * @param _converter The address of the converter\n     */\n    function setConverter(\n        address _converter\n    )\n        external\n        onlyStrategist\n    {\n        converter = IConverter(_converter);\n    }\n\n    /**\n     * @notice Sets the investEnabled status flag\n     * @param _investEnabled Bool for enabling investment\n     */\n    function setInvestEnabled(\n        bool _investEnabled\n    )\n        external\n        onlyStrategist\n    {\n        investEnabled = _investEnabled;\n    }\n\n    /**\n     * @notice Recovers stuck tokens sent directly to this contract\n     * @dev This only allows the strategist to recover unsupported tokens\n     * @param _token The address of the token\n     * @param _receiver The address to receive the tokens\n     */\n    function recoverUnsupportedToken(\n        address _token,\n        address _receiver\n    )\n        external\n        onlyStrategist\n    {\n        require(_token != address(token), \"!_token\");\n        IERC20(_token).safeTransfer(_receiver, IERC20(_token).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Returns the balance of the given token on the vault\n     */\n    function balanceOf(\n        address\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return token.balanceOf(address(this))\n                    .add(IERC20(vault.getLPToken()).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Returns the withdraw fee for withdrawing the given token and amount\n     * @param _amount The amount to withdraw\n     */\n    function withdrawFee(\n        address ,\n        uint256 _amount\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);\n    }\n\n    /**\n     * @notice Withdraws the amount from the v3 vault\n     * @param _amount The amount to withdraw\n     */\n    function withdraw(\n        address,\n        uint256 _amount\n    )\n        external\n        onlyEnabledVault\n        onlyMetaVault\n    {\n        uint256 _balance = token.balanceOf(address(this));\n        // happy path exits without calling back to the vault\n        if (_balance >= _amount) {\n            token.safeTransfer(metavault, _amount);\n            emit Withdraw(_amount);\n        } else {\n            uint256 _toWithdraw = _amount.sub(_balance);\n            IVault cachedVault = vault;\n            // convert to vault shares\n            address _token = cachedVault.getToken();\n            // get the amount of the token that we would be withdrawing\n            uint256 _expected = converter.expected(address(token), _token, _toWithdraw);\n            uint256 _shares = _expected.mul(1e18).div(cachedVault.getPricePerFullShare());\n            cachedVault.withdraw(_shares);\n            _balance = IERC20(_token).balanceOf(address(this));\n            IERC20(_token).safeTransfer(address(converter), _balance);\n            // TODO: calculate expected\n            converter.convert(_token, address(token), _balance, 1);\n            emit Withdraw(token.balanceOf(address(this)));\n            token.safeTransfer(metavault, token.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @notice Only emits the Earn event\n     * @dev This is a dummy function to allow the MetaVault to call\n     * @param _amount The amount to earn\n     */\n    function earn(\n        address,\n        uint256 _amount\n    )\n        external\n        onlyMetaVault\n    {\n        emit Earn(_amount);\n    }\n\n    /**\n     * @notice Deposits the given token to the v3 vault\n     * @param _expected The expected amount to deposit after conversion\n     */\n    function legacyDeposit(\n        uint256 _expected\n    )\n        external\n        override\n        onlyEnabledConverter\n        onlyHarvester\n    {\n        address _token = vault.getToken();\n        uint256 _amount = token.balanceOf(address(this));\n        token.safeTransfer(address(converter), _amount);\n        converter.convert(address(token), _token, _amount, _expected);\n        IERC20(_token).safeApprove(address(vault), 0);\n        IERC20(_token).safeApprove(address(vault), type(uint256).max);\n        vault.deposit(IERC20(_token).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Reverts if the converter is not set\n     */\n    modifier onlyEnabledConverter() {\n        require(address(converter) != address(0), \"!converter\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the vault is not set\n     */\n    modifier onlyEnabledVault() {\n        require(address(vault) != address(0), \"!vault\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the harvester\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the MetaVault\n     */\n    modifier onlyMetaVault() {\n        require(msg.sender == metavault, \"!metavault\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the strategist\n     */\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n"
    },
    "contracts/v3/interfaces/ILegacyVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface ILegacyVault {\n    function want() external returns (address);\n}\n"
    },
    "contracts/v3/controllers/Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IHarvester.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IManager.sol\";\n\n/**\n * @title Controller\n * @notice This controller allows multiple strategies to be used\n * for a single vault supporting multiple tokens.\n */\ncontract Controller is IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IManager public immutable override manager;\n\n    bool public globalInvestEnabled;\n    uint256 public maxStrategies;\n\n    struct VaultDetail {\n        address converter;\n        uint256 balance;\n        address[] strategies;\n        mapping(address => uint256) balances;\n        mapping(address => uint256) index;\n        mapping(address => uint256) caps;\n    }\n\n    // vault => Vault\n    mapping(address => VaultDetail) internal _vaultDetails;\n    // strategy => vault\n    mapping(address => address) internal _vaultStrategies;\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(address indexed strategy);\n\n    /**\n     * @notice Logged when a strategy is added for a vault\n     */\n    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);\n\n    /**\n     * @notice Logged when a strategy is removed for a vault\n     */\n    event StrategyRemoved(address indexed vault, address indexed strategy);\n\n    /**\n     * @notice Logged when strategies are reordered for a vault\n     */\n    event StrategiesReordered(\n        address indexed vault,\n        address indexed strategy1,\n        address indexed strategy2\n    );\n\n    /**\n     * @param _manager The address of the manager\n     */\n    constructor(\n        address _manager\n    )\n        public\n    {\n        manager = IManager(_manager);\n        globalInvestEnabled = true;\n        maxStrategies = 10;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The cap of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultDetails[_vault].converter != address(0), \"!converter\");\n        // checking if strategy is already added\n        require(_vaultStrategies[_strategy] == address(0), \"Strategy is already added\"); \n        // get the index of the newly added strategy\n        uint256 index = _vaultDetails[_vault].strategies.length;\n        // ensure we haven't added too many strategies already\n        require(index < maxStrategies, \"!maxStrategies\");\n        // push the strategy to the array of strategies\n        _vaultDetails[_vault].strategies.push(_strategy);\n        // set the cap\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        // set the index\n        _vaultDetails[_vault].index[_strategy] = index;\n        // store the mapping of strategy to the vault\n        _vaultStrategies[_strategy] = _vault;\n        if (_timeout > 0) {\n            // add it to the harvester\n            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);\n        }\n        emit StrategyAdded(_vault, _strategy, _cap);\n    }\n\n    /**\n     * @notice Withdraws token from a strategy to the treasury address as returned by the manager\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     */\n    function inCaseStrategyGetStuck(\n        address _strategy,\n        address _token\n    )\n        external\n        onlyStrategist\n    {\n        IStrategy(_strategy).withdraw(_token);\n        IERC20(_token).safeTransfer(\n            manager.treasury(),\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Withdraws token from the controller to the treasury\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function inCaseTokensGetStuck(\n        address _token,\n        uint256 _amount\n    )\n        external\n        onlyStrategist\n    {\n        IERC20(_token).safeTransfer(manager.treasury(), _amount);\n    }\n\n    /**\n     * @notice Removes a strategy for a given token\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the index of the strategy to remove\n        uint256 index = vaultDetail.index[_strategy];\n        // get the index of the last strategy\n        uint256 tail = vaultDetail.strategies.length.sub(1);\n        // get the address of the last strategy\n        address replace = vaultDetail.strategies[tail];\n        // replace the removed strategy with the tail\n        vaultDetail.strategies[index] = replace;\n        // set the new index for the replaced strategy\n        vaultDetail.index[replace] = index;\n        // remove the duplicate replaced strategy\n        vaultDetail.strategies.pop();\n        // remove the strategy's index\n        delete vaultDetail.index[_strategy];\n        // remove the strategy's cap\n        delete vaultDetail.caps[_strategy];\n        // remove the strategy's balance\n        delete vaultDetail.balances[_strategy];\n        // remove the mapping of strategy to the vault\n        delete _vaultStrategies[_strategy];\n        // pull funds from the removed strategy to the vault\n        IStrategy(_strategy).withdrawAll();\n        // remove the strategy from the harvester\n        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);\n        emit StrategyRemoved(_vault, _strategy);\n    }\n\n    /**\n     * @notice Reorders two strategies for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy1 The address of the first strategy\n     * @param _strategy2 The address of the second strategy\n     */\n    function reorderStrategies(\n        address _vault,\n        address _strategy1,\n        address _strategy2\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultStrategies[_strategy1] == _vault, \"!_strategy1\");\n        require(_vaultStrategies[_strategy2] == _vault, \"!_strategy2\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the indexes of the strategies\n        uint256 index1 = vaultDetail.index[_strategy1];\n        uint256 index2 = vaultDetail.index[_strategy2];\n        // set the new addresses at their indexes\n        vaultDetail.strategies[index1] = _strategy2;\n        vaultDetail.strategies[index2] = _strategy1;\n        // update indexes\n        vaultDetail.index[_strategy1] = index2;\n        vaultDetail.index[_strategy2] = index1;\n        emit StrategiesReordered(_vault, _strategy1, _strategy2);\n    }\n\n    /**\n     * @notice Sets/updates the cap of a strategy for a vault\n     * @dev If the balance of the strategy is greater than the new cap (except if\n     * the cap is 0), then withdraw the difference from the strategy to the vault.\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The new cap of the strategy\n     */\n    function setCap(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        address _convert\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n            updateBalance(_vault, _strategy);\n            _balance = IStrategy(_strategy).balanceOf();\n            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\n            address _want = IStrategy(_strategy).want();\n            _balance = IERC20(_want).balanceOf(address(this));\n            if (_convert != address(0)) {\n                IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n                IERC20(_want).safeTransfer(address(_converter), _balance);\n                _balance = _converter.convert(_want, _convert, _balance, 1);\n                IERC20(_convert).safeTransfer(_vault, _balance);\n            } else {\n                IERC20(_want).safeTransfer(_vault, _balance);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets/updates the converter for a given vault\n     * @param _vault The address of the vault\n     * @param _converter The address of the converter\n     */\n    function setConverter(\n        address _vault,\n        address _converter\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedConverters(_converter), \"!allowedConverters\");\n        _vaultDetails[_vault].converter = _converter;\n    }\n\n    /**\n     * @notice Sets/updates the global invest enabled flag\n     * @param _investEnabled The new bool of the invest enabled flag\n     */\n    function setInvestEnabled(\n        bool _investEnabled\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        globalInvestEnabled = _investEnabled;\n    }\n\n    /**\n     * @notice Sets/updates the maximum number of strategies for a vault\n     * @param _maxStrategies The new value of the maximum strategies\n     */\n    function setMaxStrategies(\n        uint256 _maxStrategies\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        maxStrategies = _maxStrategies;\n    }\n\n    function skim(\n        address _strategy\n    )\n        external\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).skim();\n        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Withdraws all funds from a strategy\n     * @param _strategy The address of the strategy\n     * @param _convert The token address to convert to\n     */\n    function withdrawAll(\n        address _strategy,\n        address _convert\n    )\n        external\n        override\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).withdrawAll();\n        uint256 _amount = IERC20(_want).balanceOf(address(this));\n        address _vault = _vaultStrategies[_strategy];\n        updateBalance(_vault, _strategy);\n        if (_convert != address(0)) {\n            IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n            IERC20(_want).safeTransfer(address(_converter), _amount);\n            _amount = _converter.convert(_want, _convert, _amount, 1);\n            IERC20(_convert).safeTransfer(_vault, _amount);\n        } else {\n            IERC20(_want).safeTransfer(_vault, _amount);\n        }\n        uint256 _balance = _vaultDetails[_vault].balance;\n        if (_balance >= _amount) {\n            _vaultDetails[_vault].balance = _balance.sub(_amount);\n        } else {\n            _vaultDetails[_vault].balance = 0;\n        }\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Harvests the specified strategy\n     * @param _strategy The address of the strategy\n     */\n    function harvestStrategy(\n        address _strategy,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        external\n        override\n        notHalted\n        onlyHarvester\n        onlyStrategy(_strategy)\n    {\n        uint256 _before = IStrategy(_strategy).balanceOf();\n        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);\n        uint256 _after = IStrategy(_strategy).balanceOf();\n        address _vault = _vaultStrategies[_strategy];\n        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));\n        _vaultDetails[_vault].balances[_strategy] = _after;\n        emit Harvest(_strategy);\n    }\n\n    /**\n     * VAULT-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Invests funds into a strategy\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     * @param _amount The amount that will be invested\n     */\n    function earn(\n        address _strategy,\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        notHalted\n        onlyStrategy(_strategy)\n        onlyVault()\n    {\n        // get the want token of the strategy\n        address _want = IStrategy(_strategy).want();\n        if (_want != _token) {\n            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);\n            IERC20(_token).safeTransfer(address(_converter), _amount);\n            // TODO: do estimation for received\n            _amount = _converter.convert(_token, _want, _amount, 1);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);\n        // call the strategy deposit function\n        IStrategy(_strategy).deposit();\n        updateBalance(msg.sender, _strategy);\n    }\n\n    /**\n     * @notice Withdraws funds from a strategy\n     * @dev If the withdraw amount is greater than the first strategy given\n     * by getBestStrategyWithdraw, this function will loop over strategies\n     * until the requested amount is met.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function withdraw(\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        onlyVault()\n    {\n        (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        ) = getBestStrategyWithdraw(msg.sender, _amount);\n        for (uint i = 0; i < _strategies.length; i++) {\n            // getBestStrategyWithdraw will return arrays larger than needed\n            // if this happens, simply exit the loop\n            if (_strategies[i] == address(0)) {\n                break;\n            }\n            IStrategy(_strategies[i]).withdraw(_amounts[i]);\n            updateBalance(msg.sender, _strategies[i]);\n            address _want = IStrategy(_strategies[i]).want();\n            if (_want != _token) {\n                address _converter = _vaultDetails[msg.sender].converter;\n                IERC20(_want).safeTransfer(_converter, _amounts[i]);\n                // TODO: do estimation for received\n                IConverter(_converter).convert(_want, _token, _amounts[i], 1);\n            }\n        }\n        _amount = IERC20(_token).balanceOf(address(this));\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the rough balance of the sum of all strategies for a given vault\n     * @dev This function is optimized to prevent looping over all strategy balances,\n     * and instead the controller tracks the earn, withdraw, and harvest amounts.\n     */\n    function balanceOf()\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return _vaultDetails[msg.sender].balance;\n    }\n\n    /**\n     * @notice Returns the converter assigned for the given vault\n     * @param _vault Address of the vault\n     */\n    function converter(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address)\n    {\n        return _vaultDetails[_vault].converter;\n    }\n\n    /**\n     * @notice Returns the cap of a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function getCap(\n        address _vault,\n        address _strategy\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _vaultDetails[_vault].caps[_strategy];\n    }\n\n    /**\n     * @notice Returns whether investing is enabled for the calling vault\n     * @dev Should be called by the vault\n     */\n    function investEnabled()\n        external\n        view\n        override\n        returns (bool)\n    {\n        if (globalInvestEnabled) {\n            return _vaultDetails[msg.sender].strategies.length > 0;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns all the strategies for a given vault\n     * @param _vault The address of the vault\n     */\n    function strategies(\n        address _vault\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return _vaultDetails[_vault].strategies;\n    }\n\n    /**\n     * @notice Returns the length of the strategies of the calling vault\n     * @dev This function is expected to be called by a vault\n     */\n    function strategies()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _vaultDetails[msg.sender].strategies.length;\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from\n     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays\n     * from this function will always be the same length as the amount of strategies for\n     * a token. Check that _strategies[i] != address(0) when consuming to know when to\n     * break out of the loop.\n     * @param _vault The address of the vault\n     * @param _amount The amount that will be withdrawn\n     */\n    function getBestStrategyWithdraw(\n        address _vault,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        )\n    {\n        // get the length of strategies for a single token\n        uint256 k = _vaultDetails[_vault].strategies.length;\n        // initialize fixed-length memory arrays\n        _strategies = new address[](k);\n        _amounts = new uint256[](k);\n        address _strategy;\n        uint256 _balance;\n        // scan forward from the the beginning of strategies\n        for (uint i = 0; i < k; i++) {\n            _strategy = _vaultDetails[_vault].strategies[i];\n            _strategies[i] = _strategy;\n            // get the balance of the strategy\n            _balance = _vaultDetails[_vault].balances[_strategy];\n            // if the strategy doesn't have the balance to cover the withdraw\n            if (_balance < _amount) {\n                // withdraw what we can and add to the _amounts\n                _amounts[i] = _balance;\n                _amount = _amount.sub(_balance);\n            } else {\n                // stop scanning if the balance is more than the withdraw amount\n                _amounts[i] = _amount;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the stored balance of a given strategy for a vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function updateBalance(\n        address _vault,\n        address _strategy\n    )\n        internal\n    {\n        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @notice Reverts if the protocol is halted\n     */\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not governance\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == manager.governance(), \"!governance\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the strategist\n     */\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the strategy is not allowed in the manager\n     */\n    modifier onlyStrategy(address _strategy) {\n        require(manager.allowedStrategies(_strategy), \"!allowedStrategy\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the harvester\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the vault for the given token\n     */\n    modifier onlyVault() {\n        require(manager.allowedVaults(msg.sender), \"!vault\");\n        _;\n    }\n}\n"
    },
    "contracts/mock/MockzpaToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/Stabilize.sol\";\n\ncontract MockzpaToken is ERC20, IZPAToken {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\n    uint256 constant divisionFactor = 100000;\n\n    address public override underlyingAsset;\n    uint256 public override initialFee = 1000; // 1000 = 1%, 100000 = 100%, max fee restricted in contract is 10%\n    uint256 public override endFee = 100; // 100 = 0.1%\n    uint256 public override feeDuration = 604800; // The amount of seconds it takes from the initial to end fee\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 depositTime; // The time the user made a deposit, every deposit resets the time\n    }\n\n    mapping(address => UserInfo) private userInfo;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _underlyingAsset\n    )\n        public\n        ERC20(_name, _symbol)\n    {\n        underlyingAsset = _underlyingAsset;\n    }\n\n    function deposit(uint256 _amount) external override {\n        uint256 _toMint = _amount.mul(1e18).div(pricePerToken());\n        IERC20(underlyingAsset).safeTransferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, _toMint);\n        userInfo[_msgSender()].depositTime = block.timestamp; // Update the deposit time\n    }\n\n    function redeem(uint256 _amount) external override {\n        uint256 _underlyingAmount = _amount.mul(pricePerToken()).div(1e18);\n        _burn(msg.sender, _amount);\n\n        // Pay fee upon withdrawing\n        if (userInfo[_msgSender()].depositTime == 0) {\n            // The user has never deposited here\n            userInfo[_msgSender()].depositTime = block.timestamp; // Give them the max fee\n        }\n\n        uint256 feeSubtraction = initialFee.sub(endFee).mul(block.timestamp.sub(userInfo[_msgSender()].depositTime)).div(feeDuration);\n        if (feeSubtraction > initialFee.sub(endFee)) {\n            // Cannot reduce fee more than this\n            feeSubtraction = initialFee.sub(endFee);\n        }\n        uint256 fee = initialFee.sub(feeSubtraction);\n        fee = _underlyingAmount.mul(fee).div(divisionFactor);\n        _underlyingAmount = _underlyingAmount.sub(fee);\n\n        // Now withdraw this amount to the user and send fee to treasury\n        IERC20(underlyingAsset).safeTransfer(msg.sender, _underlyingAmount);\n        IERC20(underlyingAsset).safeTransfer(DEAD, fee);\n    }\n\n    function pricePerToken() public view override returns (uint256) {\n        return 2e18;\n    }\n}\n"
    },
    "contracts/interfaces/Stabilize.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface IZPAToken {\n    function deposit(uint256) external;\n    function redeem(uint256) external;\n    function underlyingAsset() external view returns (address);\n    function pricePerToken() external view returns (uint256);\n\n    function initialFee() external view returns (uint256);\n    function endFee() external view returns (uint256);\n    function feeDuration() external view returns (uint256);\n}\n\ninterface IZPAPool {\n    function deposit(uint256, uint256) external;\n    function withdraw(uint256, uint256) external;\n    function exit(uint256, uint256) external;\n    function getReward(uint256) external;\n    function rewardEarned(uint256, address) external view returns (uint256);\n    function poolTokenAddress(uint256) external view returns (address);\n    function poolBalance(uint256, address) external view returns (uint256);\n}\n"
    },
    "contracts/mock/MockStabilizePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/Stabilize.sol\";\n\ncontract MockStabilizePool is IZPAPool {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 public lpToken;\n    IERC20 public rewardToken;\n    uint256 public rewardRate;\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n        uint256 unclaimedReward;\n    }\n\n    mapping(uint256 => mapping(address => UserInfo)) private userInfo;\n    mapping(uint256 => address) public override poolTokenAddress;\n\n    constructor(\n        address _lpToken,\n        address _rewardToken,\n        uint256 _rewardRate\n    ) public {\n        lpToken = IERC20(_lpToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardRate = _rewardRate;\n    }\n\n    function deposit(uint256 _pid, uint256 _amount) external override {\n        userInfo[_pid][msg.sender].amount = userInfo[_pid][msg.sender].amount.add(_amount);\n        lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function withdraw(uint256 _pid, uint256 _amount) public override {\n        userInfo[_pid][msg.sender].amount = userInfo[_pid][msg.sender].amount.sub(_amount);\n        lpToken.safeTransfer(msg.sender, _amount);\n    }\n\n    function exit(uint256 _pid, uint256 _amount) external override {\n        withdraw(_pid, _amount);\n        getReward(_pid);\n    }\n\n    function getReward(uint256 _pid) public override {\n        uint256 _amount = rewardEarned(_pid, msg.sender);\n        rewardToken.safeTransfer(msg.sender, _amount);\n    }\n\n    function rewardEarned(uint256 _pid, address _user) public view override returns (uint256) {\n        return poolBalance(_pid, _user).mul(rewardRate).div(1000);\n    }\n\n    function poolBalance(uint256 _pid, address _user) public view override returns (uint256) {\n        return userInfo[_pid][_user].amount;\n    }\n}\n"
    },
    "contracts/mock/MockYearnV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockYearnV2 is ERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public underlying;\n\n    constructor(string memory name, string memory symbol, IERC20 _underlying) public ERC20(name, symbol) {\n        underlying = _underlying;\n    }\n\n    function balance() public view returns (uint256) {\n        return underlying.balanceOf(address(this));\n    }\n\n    function pricePerShare() public view returns (uint256) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    function deposit() external returns (uint256) {\n        uint256 _balance = underlying.balanceOf(msg.sender);\n        return deposit(_balance);\n    }\n\n    function deposit(uint256 _amount) public returns (uint256) {\n        uint256 underlyingTotal = balance();\n        uint256 _before = balance();\n        underlying.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = balance();\n        _amount = _after.sub(_before);\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(underlyingTotal);\n        }\n        _mint(msg.sender, shares);\n        return shares;\n    }\n\n    function withdraw() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    function withdraw(uint256 _amount) public {\n        uint256 ret = (balance().mul(_amount)).div(totalSupply());\n        _burn(msg.sender, _amount);\n        underlying.safeTransfer(msg.sender, ret);\n    }\n\n    function token() external view returns (address) {\n        return address(underlying);\n    }\n}\n"
    },
    "contracts/mock/MockIdleToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/Idle.sol\";\n\ncontract MockIdleToken is ERC20, IIdleTokenV3_1 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public override token;\n    IERC20 public rewardToken;\n    IERC20 public govToken;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _underlyingAsset,\n        address _rewardToken,\n        address _govToken\n    )\n        public\n        ERC20(_name, _symbol)\n    {\n        token = _underlyingAsset;\n        rewardToken = ERC20(_rewardToken);\n        govToken = ERC20(_govToken);\n    }\n\n    function mintIdleToken(uint256 _amount, bool, address) external override returns (uint256 mintedTokens) {\n        mintedTokens = _amount.mul(1e18).div(tokenPrice());\n        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, mintedTokens);\n    }\n\n    function redeemIdleToken(uint256 _amount) external override returns (uint256 redeemedTokens) {\n        uint256 price = tokenPrice();\n        redeemedTokens = _amount.mul(price).div(1e18);\n        _burn(msg.sender, _amount);\n        rewardToken.safeTransfer(msg.sender, 10e18);\n        govToken.safeTransfer(msg.sender, 5e18);\n        IERC20(token).safeTransfer(msg.sender, redeemedTokens);\n    }\n\n    function tokenPrice() public view override returns (uint256) {\n        return 2e18; // 1 idleDAI = 2 DAI\n    }\n}\n"
    },
    "contracts/interfaces/Idle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.2;\n\ninterface IIdleTokenV3_1 {\n    function tokenPrice() external view returns (uint256 price);\n    function token() external view returns (address);\n    function mintIdleToken(uint256 _amount, bool _skipRebalance, address _referral) external returns (uint256 mintedTokens);\n    function redeemIdleToken(uint256 _amount) external returns (uint256 redeemedTokens);\n}\n"
    },
    "contracts/mock/MockDErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockDErc20 is ERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public underlying;\n\n    constructor(string memory name, string memory symbol, IERC20 _underlying) public ERC20(name, symbol) {\n        underlying = _underlying;\n    }\n\n    function getExchangeRate() public pure returns (uint256) {\n        return 2e18; // 1 dDAI = 2 DAI\n    }\n\n    function getTokenBalance(address _account) external view returns (uint256) {\n        return balanceOf(_account).mul(getExchangeRate()).div(1e18);\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        uint256 _toMint = _amount.mul(1e18).div(getExchangeRate());\n        underlying.safeTransferFrom(msg.sender, address(this), _amount);\n        _mint(_account, _toMint);\n    }\n\n    function redeem(address _account, uint256 _amount) external {\n        uint256 _underlyingAmount = _amount.mul(getExchangeRate()).div(1e18);\n        _burn(_account, _amount);\n        underlying.safeTransfer(msg.sender, _underlyingAmount);\n    }\n}\n"
    },
    "contracts/legacy/mock/MockYaxisBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockYaxisBar is ERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable YAX;\n\n    constructor(\n        address _yax\n    )\n        public\n        ERC20(\"Staked yAxis\", \"sYAX\")\n    {\n        YAX = IERC20(_yax);\n    }\n\n    function availableBalance()\n        external\n        view\n        returns (uint256)\n    {\n        return YAX.balanceOf(address(this));\n    }\n\n    function enter(\n        uint256 _amount\n    )\n        external\n    {\n        require(_amount > 0, \"!_amount\");\n        _mint(msg.sender, _amount.mul(1e18).div(getPricePerFullShare()));\n        YAX.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function leave(\n        uint256 _amount\n    )\n        public\n    {\n        require(_amount > 0, \"!_amount\");\n        _burn(msg.sender, _amount);\n        YAX.safeTransfer(msg.sender, _amount.mul(getPricePerFullShare()).div(1e18));\n    }\n\n    function exit()\n        external\n    {\n        leave(balanceOf(msg.sender));\n    }\n\n    function getPricePerFullShare()\n        public\n        view\n        returns (uint256)\n    {\n        return totalSupply() == 0\n            ? 1e18\n            : YAX.balanceOf(address(this)).mul(1e18).div(totalSupply());\n    }\n}\n"
    },
    "contracts/legacy/mock/MockUniswapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockUniswapPair is ERC20 {\n    using SafeERC20 for IERC20;\n\n    address public immutable token0;\n    address public immutable token1;\n\n    constructor(\n        address _token0,\n        address _token1\n    )\n        public\n        ERC20(\"Uniswap Pair\", \"UNI-V2\")\n    {\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    function addLiquidity(\n        uint256 _amount0,\n        uint256 _amount1,\n        uint256 _amountOut\n    )\n        external\n    {\n        IERC20(token0).safeTransferFrom(msg.sender, address(this), _amount0);\n        IERC20(token1).safeTransferFrom(msg.sender, address(this), _amount1);\n        _mint(msg.sender, _amountOut);\n    }\n\n    function getReserves()\n        external\n        view\n        returns (uint112, uint112, uint32)\n    {\n        return (\n            uint112(IERC20(token0).balanceOf(address(this))),\n            uint112(IERC20(token1).balanceOf(address(this))),\n            uint32(block.timestamp)\n        );\n    }\n}\n"
    },
    "contracts/token/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable var-name-mixedcase\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IsYAX.sol\";\n\n/**\n * @title Swap\n * @notice This contract swaps a user's YAX and sYAX to the YAXIS token\n * If the user does not have YAX or sYAX, it will not attempt to swap\n * those assets in order to save gas.\n */\ncontract Swap {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 public immutable YAXIS;\n    IERC20 public immutable YAX;\n    IERC20 public immutable SYAX;\n\n    /**\n     * @param _yaxis The YAXIS token address\n     * @param _yax The YAX token address\n     * @param _syax The sYAX token address\n     */\n    constructor(\n        address _yaxis,\n        address _yax,\n        address _syax\n    )\n        public\n    {\n        YAXIS = IERC20(_yaxis);\n        YAX = IERC20(_yax);\n        SYAX = IERC20(_syax);\n    }\n\n    /**\n     * @notice Swaps the user's YAX and sYAX for YAXIS\n     * @dev Assumes this contract should never hold YAX directly\n     * because it will send its entire balance to the caller.\n     * @dev This contract must be funded with YAXIS before\n     * users can call swap().\n     */\n    function swap()\n        external\n    {\n        uint256 _balance = YAX.balanceOf(address(this));\n        uint256 _amount = SYAX.balanceOf(msg.sender);\n        if (_amount > 0) {\n            SYAX.safeTransferFrom(msg.sender, address(this), _amount);\n            IsYAX(address(SYAX)).exit();\n        }\n        _amount = YAX.balanceOf(msg.sender);\n        if (_amount > 0) {\n            YAX.safeTransferFrom(msg.sender, address(this), _amount);\n        }\n        _amount = YAX.balanceOf(address(this)).sub(_balance);\n        if (_amount > 0) {\n            YAXIS.safeTransfer(msg.sender, _amount);\n        }\n    }\n}\n"
    },
    "contracts/token/interfaces/IsYAX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IsYAX {\n    function exit() external;\n}\n"
    },
    "contracts/mock/MockUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ninterface IUniswapRouter {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n}\n\ncontract MockUniswapRouter is IUniswapRouter {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 univ2LpToken;\n\n    constructor(IERC20 _univ2LpToken) public {\n        univ2LpToken = _univ2LpToken;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) public override returns (uint256[] memory amounts) {\n        return _swap(amountIn, amountOutMin, path, to, deadline);\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external override returns (uint256[] memory amounts) {\n        return _swap(amountIn, amountOutMin, path, to, deadline);\n    }\n\n    function _swap(\n        uint256 amountIn,\n        uint256,\n        address[] calldata path,\n        address to,\n        uint256\n    ) internal returns (uint256[] memory amounts) {\n        uint256 amountOut = amountIn.mul(1); // assume 1 INPUT -> 1 OUTPUT\n        IERC20 inputToken = IERC20(path[0]);\n        IERC20 outputToken = IERC20(path[path.length - 1]);\n        inputToken.safeTransferFrom(msg.sender, address(this), amountIn);\n        outputToken.safeTransfer(to, amountOut);\n        amounts = new uint256[](2);\n        amounts[0] = amountIn;\n        amounts[1] = amountOut;\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint,\n        uint,\n        address to,\n        uint\n    ) external override returns (uint amountA, uint amountB, uint liquidity) {\n        amountA = (amountADesired < amountBDesired) ? amountADesired : amountBDesired;\n        amountB = amountA;\n        liquidity = amountA;\n        IERC20(tokenA).safeTransferFrom(msg.sender, address(this), amountA);\n        IERC20(tokenB).safeTransferFrom(msg.sender, address(this), amountB);\n        univ2LpToken.safeTransfer(to, liquidity); // 1A + 1B -> 1LP\n    }\n}\n"
    },
    "contracts/mock/MockDRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract MockDRewards {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public lpToken;\n    IERC20 public rewardToken;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 rewardRate; // over 1000\n\n    constructor(\n        address _lpToken,\n        address _rewardToken,\n        uint256 _rewardRate\n    ) public {\n        lpToken = IERC20(_lpToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardRate = _rewardRate;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return balanceOf(account).mul(rewardRate).div(1000);\n    }\n\n    function stake(uint256 amount) public {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        lpToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        lpToken.safeTransfer(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            if (reward > rewardToken.balanceOf(address(this))) {\n                reward = rewardToken.balanceOf(address(this));\n            }\n            rewardToken.safeTransfer(msg.sender, reward);\n        }\n    }\n}\n"
    },
    "contracts/mock/MockCurveMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/Gauge.sol\";\n\ncontract MockCurveMinter is Mintr {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 crv;\n\n    constructor(IERC20 _crv) public {\n        crv = _crv;\n    }\n\n    function mint(address) external override {\n        uint _bal = crv.balanceOf(address(this));\n        crv.safeTransfer(msg.sender, _bal.div(10)); // always mint 10% amount of balance\n    }\n}\n"
    },
    "contracts/mock/MockCurveGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../interfaces/Gauge.sol\";\n\ncontract MockCurveGauge is Gauge {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 want;\n\n    mapping(address => uint) public amounts;\n\n    constructor(IERC20 _want) public {\n        want = _want;\n    }\n\n    function deposit(uint _amount) external override {\n        want.safeTransferFrom(msg.sender, address(this), _amount);\n        amounts[msg.sender] = amounts[msg.sender].add(_amount);\n    }\n\n    function balanceOf(address _account) external override view returns (uint) {\n        return amounts[_account];\n    }\n\n    function claimable_tokens(address _account) external override view returns (uint) {\n        return amounts[_account].div(10); // always return 10% of staked\n    }\n\n    function withdraw(uint _amount) external override {\n        want.safeTransfer(msg.sender, _amount);\n        amounts[msg.sender] = amounts[msg.sender].sub(_amount);\n    }\n}\n"
    },
    "contracts/token/MerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport \"./interfaces/IMerkleDistributor.sol\";\n\ncontract MerkleDistributor is IMerkleDistributor {\n    address public immutable override token;\n    bytes32 public immutable override merkleRoot;\n\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    constructor(address token_, bytes32 merkleRoot_) public {\n        token = token_;\n        merkleRoot = merkleRoot_;\n    }\n\n    function isClaimed(uint256 index) public view override returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {\n        require(!isClaimed(index), 'MerkleDistributor: Drop already claimed.');\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), 'MerkleDistributor: Invalid proof.');\n\n        // Mark it claimed and send the token.\n        _setClaimed(index);\n        require(IERC20(token).transfer(account, amount), 'MerkleDistributor: Transfer failed.');\n\n        emit Claimed(index, account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "contracts/token/interfaces/IMerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n// Allows anyone to claim a token if they exist in a merkle root.\ninterface IMerkleDistributor {\n    // Returns the address of the token distributed by this contract.\n    function token() external view returns (address);\n    // Returns the merkle root of the merkle tree containing account balances available to claim.\n    function merkleRoot() external view returns (bytes32);\n    // Returns true if the index has been marked claimed.\n    function isClaimed(uint256 index) external view returns (bool);\n    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external;\n\n    // This event is triggered whenever a call to #claim succeeds.\n    event Claimed(uint256 index, address account, uint256 amount);\n}\n"
    },
    "contracts/token/interfaces/IERC677.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC677 is IERC20 {\n    function transferAndCall(address, address, uint256, bytes calldata) external returns (bool);\n}\n"
    },
    "contracts/mock/MockPickleMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockPickleMasterChef {\n    IERC20 public pickleToken;\n    IERC20 public lpToken;\n\n    struct UserInfo {\n        uint amount; // How many LP tokens the user has provided.\n        uint rewardDebt; // Reward debt. See explanation below.\n    }\n\n    mapping(uint => mapping(address => UserInfo)) public userInfo;\n\n    constructor(IERC20 _pickleToken, IERC20 _lpToken) public {\n        pickleToken = _pickleToken;\n        lpToken = _lpToken;\n    }\n\n    function deposit(uint _pid, uint _amount) external {\n        lpToken.transferFrom(msg.sender, address(this), _amount);\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pickleToken.transfer(msg.sender, user.amount / 10); // always get 10% of deposited amount\n        user.amount = user.amount + _amount;\n    }\n\n    function withdraw(uint _pid, uint _amount) external {\n        lpToken.transfer(msg.sender, _amount);\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pickleToken.transfer(msg.sender, user.amount / 10); // always get 10% of deposited amount\n        user.amount = user.amount - _amount;\n    }\n\n    function pendingPickle(uint, address) external view returns (uint) {\n        return pickleToken.balanceOf(address(this)) / 10;\n    }\n\n    function emergencyWithdraw(uint _pid) external {\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        lpToken.transfer(msg.sender, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n    }\n}\n"
    },
    "contracts/governance/interfaces/IYaxisBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IYaxisBar is IERC20 {\n    function availableBalance() external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}